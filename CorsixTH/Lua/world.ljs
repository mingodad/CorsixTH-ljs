/* Copyright (c) 2009 Peter "Corsix" Cawley

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE. --*/

var TH = require("TH");
var ipairs, _G, table_remove
    = ipairs, _G, table.remove;

corsixth.require("entities.patient");
corsixth.require("entities.staff");
corsixth.require("entities.vip");
corsixth.require("entities.grim_reaper");
corsixth.require("entities.inspector");
corsixth.require("staff_profile");
corsixth.require("hospital");
corsixth.require("epidemic");
corsixth.require("calls_dispatcher");
corsixth.require("research_department");
corsixth.require("entity_map");
corsixth.require("date");

//! Manages entities, rooms, and the date.
class ("World");

//-@type World
var World = _G["World"];

var local_criteria_variable = {
  {name = "reputation",       icon = 10, formats = 2},
  {name = "balance",          icon = 11, formats = 2},
  {name = "percentage_cured", icon = 12, formats = 2},
  {name = "num_cured" ,       icon = 13, formats = 2},
  {name = "percentage_killed",icon = 14, formats = 2},
  {name = "value",            icon = 15, formats = 2},
  {name = "population",       icon = 11, formats = 1},
};

// time between each damage caused by an earthquake
var earthquake_damage_time = 16; // hours
var earthquake_warning_period = 600; // hours between warning and real thing
var earthquake_warning_length = 25; // length of early warning quake

function World::World(app) {
  this.map = app.map;
  this.wall_types = app.walls;
  this.object_types = app.objects;
  this.anims = app.anims;
  this.animation_manager = app.animation_manager;
  this.pathfinder = TH.pathfinder();
  this.pathfinder->setMap(app.map.th);
  this.entities = {}; // List of entities in the world.
  this.dispatcher = CallsDispatcher(this);
  this.objects = {};
  this.object_counts = {
    extinguisher = 0,
    radiator = 0,
    plant = 0,
    reception_desk = 0,
    bench = 0,
    general = 0,
  };
  this.objects_notify_occupants = {};
  this.rooms = {}; // List that can have gaps when a room is deleted, so use pairs to iterate.
  this.entity_map = EntityMap(this.map);

  // All information relating to the next or current earthquake, nil if
  // there is no scheduled earthquake.
  // Contains the following fields:
  // active (boolean) Whether we are currently running the warning or damage timers (after start_day of start_month is passed).
  // start_month (integer) The month the earthquake warning is triggered.
  // start_day (integer) The day of the month the earthquake warning is triggered.
  // size (integer) The amount of damage the earthquake causes (1-9).
  // remaining_damage (integer) The amount of damage this earthquake has yet to inflict.
  // damage_timer (integer) The number of hours until the earthquake next inflicts damage if active.
  // warning_timer (integer) The number of hours left until the real damaging earthquake begins.
  this.next_earthquake = { active = false };

  // Time
  this.hours_per_tick = 1;
  this.tick_rate = 3;
  this.tick_timer = 0;
  this.game_date = Date();

  this.room_information_dialogs_off = app.config.debug;
  // This is false when the game is paused.
  this.user_actions_allowed = true;

  // In Free Build mode?
  if( tonumber(this.map.level_number) ) {
    this.free_build_mode = false;
  } else {
    this.free_build_mode = app.config.free_build_mode;
    this.debug_disable_salary_raise = this.free_build_mode;
  }

  this.debug_disable_salary_raise = false;
  this.idle_cache = {};
  // List of which goal criterion means what, and what number the corresponding icon has.
  this.level_criteria = local_criteria_variable;
  this.room_remove_callbacks = {/*a set rather than a list*/};
  this.room_built = {}; // List of room types that have been built
  this.hospitals = {};
  this.floating_dollars = {};
  this.game_log = {}; // saves list of useful debugging information
  this.savegame_version = app.savegame_version;
  // Also preserve this throughout future updates.
  this.original_savegame_version = app.savegame_version;

  // Initialize available rooms.
  var avail_rooms = this->getAvailableRooms();
  this.available_rooms = {}; // Both a list and a set, use ipairs to iterate through the available rooms.
  for( _, avail_room in ipairs(avail_rooms) ) {
    var room = avail_room.room;
    this.available_rooms[#this.available_rooms + 1] = room;
    this.available_rooms[room.id] = room;
  }

  // Initialize available diseases and winning conditions.
  this->initLevel(app, avail_rooms);

  this.hospitals[1] = Hospital(this, avail_rooms, app.config.player_name); // Player's hospital
  this->initCompetitors(avail_rooms);
  for( _, hospital in ipairs(this.hospitals) ) {
    hospital.research->setResearchConcentration();
  }

  // TODO: Add (working) AI and/or multiplayer hospitals
  // TODO: Needs to be changed for multiplayer support
  this.hospitals[1]->initStaff();

  this.wall_id_by_block_id = {};
  for( _, wall_type in ipairs(this.wall_types) ) {
    for( _, set in ipairs({"inside_tiles", "outside_tiles", "window_tiles"}) ) {
      for( _, id in pairs(wall_type[set]) ) {
        this.wall_id_by_block_id[id] = wall_type.id;
      }
    }
  }
  this.wall_set_by_block_id = {};
  for( _, wall_type in ipairs(this.wall_types) ) {
    for( _, set in ipairs({"inside_tiles", "outside_tiles", "window_tiles"}) ) {
      for( _, id in pairs(wall_type[set]) ) {
        this.wall_set_by_block_id[id] = set;
      }
    }
  }
  this.wall_dir_by_block_id = {};
  for( _, wall_type in ipairs(this.wall_types) ) {
    for( _, set in ipairs({"inside_tiles", "outside_tiles", "window_tiles"}) ) {
      for( name, id in pairs(wall_type[set]) ) {
        this.wall_dir_by_block_id[id] = name;
      }
    }
  }

  this.object_id_by_thob = {};
  for( _, object_type in ipairs(this.object_types) ) {
    this.object_id_by_thob[object_type.thob] = object_type.id;
  }
  this->makeAvailableStaff(0);
  this->calculateSpawnTiles();

  // Next Events dates
  this->nextEmergency();
  this.next_vip_date = this->_generateNextVipDate();

  // earthquakes
  // current_map_earthquakes is a counter that tracks which number of earthquake
  // we are currently on in maps which have information for earthquakes in them
  this.current_map_earthquake = 0;
  this->nextEarthquake();

  // Set initial spawn rate in people per month.
  // Assumes that the first entry is always the first month.
  this.spawn_rate = this.map.level_config.popn[0].Change;
  this.monthly_spawn_increase = this.spawn_rate;

  this.spawn_hours = {};
  this.spawn_dates = {};
  this->updateSpawnDates();

  this.cheat_announcements = {
    "cheat001.wav", "cheat002.wav", "cheat003.wav",
  };

  this->gameLog("Created game with savegame version " .. this.savegame_version .. ".");
}

//! Register key shortcuts for controlling the world (game speed, etc.)
function World::setUI(ui) {
  this.ui = ui;
  this.ui->addKeyHandler("P", this, this.pauseOrUnpause, "Pause");
  this.ui->addKeyHandler("1", this, this.setSpeed, "Slowest");
  this.ui->addKeyHandler("2", this, this.setSpeed, "Slower");
  this.ui->addKeyHandler("3", this, this.setSpeed, "Normal");
  this.ui->addKeyHandler("4", this, this.setSpeed, "Max speed");
  this.ui->addKeyHandler("5", this, this.setSpeed, "And then some more");

  this.ui->addKeyHandler("=", this, this.adjustZoom,  1);
  this.ui->addKeyHandler({"shift", "="}, this, this.adjustZoom, 5);
  this.ui->addKeyHandler("+", this, this.adjustZoom,  1);
  this.ui->addKeyHandler({"shift", "+"}, this, this.adjustZoom, 5);
  this.ui->addKeyHandler("-", this, this.adjustZoom, -1);
  this.ui->addKeyHandler({"shift", "-"}, this, this.adjustZoom, -5);
}

function World::adjustZoom(delta) {
  var scr_w = this.ui.app.config.width;
  var factor = this.ui.app.config.zoom_speed;
  var virtual_width = scr_w / (this.ui.zoom_factor || 1);

  // The modifier is a normal distribution to make it more difficult to zoom at the extremes
  var modifier = math.exp(-((this.ui.zoom_factor - 1) ** 2) / 2) / math.sqrt(2 * math.pi);

  if( modifier < 0.05 || modifier > 1 ) {
    modifier = 0.05;
  }

  virtual_width = virtual_width - delta * factor * modifier;
  if( virtual_width < 200 ) {
    return false;
  }

  return this.ui->setZoom(scr_w / virtual_width);
}

//! Initialize the game level (available diseases, winning conditions).
//!param app Game application.
//!param avail_rooms (list) Available rooms in the level.
function World::initLevel(app, avail_rooms) {
  var existing_rooms = {};
  for( _, avail_room in ipairs(avail_rooms) ) {
    existing_rooms[avail_room.room.id] = true;
  }

  // Determine available diseases
  this.available_diseases = {};
  var level_config = this.map.level_config;
  var visual = level_config.visuals;
  var non_visual = level_config.non_visuals;
  for( _, disease in ipairs(app.diseases) ) {
    if( ! disease.pseudo ) {
      var vis_id = disease.visuals_id;
      var nonvis_id = disease.non_visuals_id;

      var vis = 1;
      if( visual && (visual[vis_id] || non_visual[nonvis_id]) ) {
        vis = vis_id && visual[vis_id].Value || non_visual[nonvis_id].Value;
      }
      if( vis != 0 ) {
        for( _, room_id in ipairs(disease.treatment_rooms) ) {
          if( existing_rooms[room_id] == null ) {
            print("Warning: Removing disease \"" .. disease.id ..
                  "\" due to missing treatment room \"" .. room_id .. "\".");
            vis = 0; // Missing treatment room, disease cannot be treated. Remove it.
            break;
          }
        }
      }
      // TODO: Where the value is greater that 0 should determine the frequency of the patients
      if( vis != 0 ) {
        this.available_diseases[#this.available_diseases + 1] = disease;
        this.available_diseases[disease.id] = disease;
      }
    }
  }
  if( #this.available_diseases == 0 && ! this.map.level_number == "MAP EDITOR" ) {
    // No diseases are needed if we're actually in the map editor!
    print("Warning: This level does not contain any diseases");
  }

  this->determineWinningConditions();
}

function World::toggleInformation() {
  this.room_information_dialogs_off = ! this.room_information_dialogs_off;
}

//! Load goals to win and lose from the map, and store them in 'self.goals'.
//! Also set 'self.winning_goal_count'.
function World::determineWinningConditions() {
  var winning_goal_count = 0;
  // No conditions if in free build mode!
  if( this.free_build_mode ) {
    this.goals = {};
    this.winning_goal_count = winning_goal_count;
    return;
  }
  // Determine winning and losing conditions
  var world_goals = {};

  // There might be no winning criteria (i.e. the demo), then
  // we don't have to worry about the progress report dialog
  // since it doesn't exist anyway.
  var win = this.map.level_config.win_criteria;
  if( win ) {
    for( _, values in pairs(win) ) {
      if( values.Criteria != 0 ) {
        ++winning_goal_count    ;
        var crit_name = this.level_criteria[values.Criteria].name;
        world_goals[crit_name] = {
          name = crit_name,
          win_value = values.Value,
          boundary = values.Bound,
          criterion = values.Criteria,
          max_min_win = values.MaxMin,
          group = values.Group,
          number = winning_goal_count,
        };
        world_goals[#world_goals + 1] = world_goals[crit_name];
      }
    }
  }
  // Likewise there might be no losing criteria (i.e. the demo)
  var lose = this.map.level_config.lose_criteria;
  if( lose ) {
    for( _, values in pairs(lose) ) {
      if( values.Criteria != 0 ) {
        var crit_name = this.level_criteria[values.Criteria].name;
        if( ! world_goals[crit_name] ) {
          world_goals[crit_name] = {number = #world_goals + 1, name = crit_name};
          world_goals[#world_goals + 1] = world_goals[crit_name];
        }
        world_goals[crit_name].lose_value = values.Value;
        world_goals[crit_name].boundary = values.Bound;
        world_goals[crit_name].criterion = values.Criteria;
        world_goals[crit_name].max_min_lose = values.MaxMin;
        world_goals[crit_name].group = values.Group;
        world_goals[world_goals[crit_name].number].lose_value = values.Value;
        world_goals[world_goals[crit_name].number].boundary = values.Bound;
        world_goals[world_goals[crit_name].number].criterion = values.Criteria;
        world_goals[world_goals[crit_name].number].max_min_lose = values.MaxMin;
        world_goals[world_goals[crit_name].number].group = values.Group;
      }
    }
  }

  // Order the criteria (some icons in the progress report shouldn't be next to each other)
  table.sort(world_goals, function(a,b) { return a.criterion < b.criterion; });
  this.goals = world_goals;
  this.winning_goal_count = winning_goal_count;
}

//! Find the rooms available at the level.
//!return (list) Available rooms, with discovery state at start, and build_cost.
function World::getAvailableRooms() {
  var avail_rooms = {};

  var cfg_objects = this.map.level_config.objects;
  var cfg_rooms = this.map.level_config.rooms;
  for( _, room in ipairs(TheApp.rooms) ) {
    // Add build cost based on level files for all rooms.
    // For now, sum it up so that the result is the same as before.
    // TODO: Change the whole build process so that this value is
    // the room cost only? (without objects)
    var build_cost = cfg_rooms[room.level_config_id].Cost;
    var available = true;
    var is_discovered = true;
    // Make sure that all objects needed for this room are available
    for( name, no in pairs(room.objects_needed) ) {
      var spec = cfg_objects[TheApp.objects[name].thob];
      if( spec.AvailableForLevel == 0 ) {
        // It won't be possible to build this room at all on the level.
        available = false;
      } else if( spec.StartAvail == 0 ) {
        // Ok, it will be available at some point just not from the beginning.
        is_discovered = false;
      }
      // Add cost for this object.
      build_cost = build_cost + cfg_objects[TheApp.objects[name].thob].StartCost * no;
    }

    if( available ) {
      avail_rooms[#avail_rooms + 1] = {room = room, is_discovered = is_discovered, build_cost = build_cost};
    }
  }
  return avail_rooms;
}

//! Initialize competing hospitals
//!param avail_rooms (list) Available rooms in the level.
function World::initCompetitors(avail_rooms) {
  // Add computer players
  // TODO: Right now they're only names
  var level_config = this.map.level_config;
  for( key, value in pairs(level_config.computer) ) {
    if( value.Playing == 1 ) {
      this.hospitals[#this.hospitals + 1] = AIHospital(tonumber(key) + 1, this, avail_rooms);
    }
  }
}

//! Initializes variables carried from previous levels
function World::initFromPreviousLevel(carry) {
  for( object, tab in pairs(carry) ) {
    if( object == "world" ) {
      for( key, value in pairs(tab) ) {
        this[key] = value;
      }
    } else if( object == "hospital" ) {
      for( key, value in pairs(tab) ) {
        this.hospitals[1][key] = value;
      }
    }
  }
}

//! Get the hospital controlled by the (single) player.
//!return (Hospital) The hospital controlled by the (single) player.
function World::getLocalPlayerHospital() {
  // NB: UI code can get the hospital to use via ui.hospital
  // TODO: Make this work in multiplayer?
  return this.hospitals[1];
}

//! Identify the tiles on the map suitable for spawning `Humanoid`s from.
function World::calculateSpawnTiles() {
  this.spawn_points = {};
  var w, h = this.map.width, this.map.height;
  var directions = {
    {direction = "north", origin = {1, 1}, step = { 1,  0}},
    {direction = "east" , origin = {w, 1}, step = { 0,  1}},
    {direction = "south", origin = {w, h}, step = {-1,  0}},
    {direction = "west" , origin = {1, h}, step = { 0, -1}},
  };
  for( _, edge in ipairs(directions) ) {
    // Find all possible spawn points on the edge
    var xs = {};
    var ys = {};
    var x, y = edge.origin[1], edge.origin[2];
    do {
      if( this.pathfinder->isReachableFromHospital(x, y) ) {
        xs[#xs + 1] = x;
        ys[#ys + 1] = y;
      }
      x = x + edge.step[1];
      y = y + edge.step[2];
    } while(!( x < 1 || x > w || y < 1 || y > h) );

    // Choose at most 8 points for the edge
    var num = math.min(8, #xs);
    for( i = 1, num ) {
      var index = math.floor((i - 0.5) / num * #xs + 1);
      this.spawn_points[#this.spawn_points + 1] = {x = xs[index], y = ys[index], direction = edge.direction};
    }
  }
}

//! Function to determine whether a given disease is available for new patients.
//!param self (World) World object.
//!param disease (disease) Disease to test.
//!param hospital (Hospital) Hospital that needs a new patient.
//!return (boolean) Whether the disease is usable for new spawned patients.
var function isDiseaseUsableForNewPatient(this, disease, hospital) {
  if( disease.only_emergency ) { return false; }
  if( ! disease.visuals_id ) { return true; }

  // level files can delay visuals to a given month
  // and / or until a given number of patients have arrived
  var level_config = this.map.level_config;
  var hold_visual_months = level_config.gbv.HoldVisualMonths;
  var hold_visual_peep_count = level_config.gbv.HoldVisualPeepCount;

  // if the month is greater than either of these values then visuals will not appear in the game
  if( (hold_visual_months && hold_visual_months > this.game_date->monthOfGame()) ||
      (hold_visual_peep_count && hold_visual_peep_count > hospital.num_visitors) ) {
    return false;
  }

  // The value against #visuals_available determines from which month a disease can appear.
  // 0 means it can show up anytime.
  return level_config.visuals_available[disease.visuals_id].Value < this.game_date->monthOfGame();
}

//! Spawn a patient from a spawn point for the given hospital.
//!param hospital (Hospital) Hospital that the new patient should visit.
//!return (Patient entity) The spawned patient, or 'nil' if no patient spawned.
function World::spawnPatient(hospital) {
  if( ! hospital ) {
    hospital = this->getLocalPlayerHospital();
  }

  // The level might not contain any diseases
  if( #this.available_diseases < 1 ) {
    this.ui->addWindow(UIInformation(this.ui, {"There are no diseases on this level! Please add some to your level."}));
    return;
  }
  if( #this.spawn_points == 0 ) {
    this.ui->addWindow(UIInformation(this.ui, {"Could not spawn patient because no spawn points are available. Please place walkable tiles on the edge of your level."}));
    return;
  }

  if( ! hospital->hasStaffedDesk() ) { return null; }

  // Construct disease, take a random guess first, as a quick clear-sky attempt.
  var disease = this.available_diseases[math.random(1, #this.available_diseases)];
  if( ! isDiseaseUsableForNewPatient(this, disease, hospital) ) {
    // Lucky shot failed, do a proper calculation.
    var usable_diseases = {};
    for( _, d in ipairs(this.available_diseases) ) {
      if( isDiseaseUsableForNewPatient(this, d, hospital) ) {
        usable_diseases[#usable_diseases + 1] = d;
      }
    }

    if( #usable_diseases == 0 ) { return null; }

    disease = usable_diseases[math.random(1, #usable_diseases)];
  }

  // Construct patient.
  var spawn_point = this.spawn_points[math.random(1, #this.spawn_points)];
  var patient = this->newEntity("Patient", 2);
  patient->setDisease(disease);
  patient->setNextAction(SpawnAction("spawn", spawn_point));
  patient->setHospital(hospital);
  return patient;
}

//A VIP is invited (or he invited himself) to the player hospital.
//!param name Name of the VIP
function World::spawnVIP(name) {
  var hospital = this->getLocalPlayerHospital();

  var vip = this->newEntity("Vip", 2);
  vip->setType("VIP");
  vip.name = name;
  vip.enter_deaths = hospital.num_deaths;
  vip.enter_visitors = hospital.num_visitors;
  vip.enter_cures = hospital.num_cured;

  vip.enter_explosions = hospital.num_explosions;

  var spawn_point = this.spawn_points[math.random(1, #this.spawn_points)];
  vip->setNextAction(SpawnAction("spawn", spawn_point));
  vip->setHospital(hospital);
  vip->updateDynamicInfo();
  hospital.announce_vip = hospital.announce_vip + 1;
  vip->queueAction(SeekReceptionAction());
}

//! Perform actions to simulate an active earthquake.
function World::tickEarthquake() {
  if( this->isCurrentSpeed("Pause") ) { return; }

  // check if this is the day that the earthquake is supposed to stop
  if( this.next_earthquake.remaining_damage == 0 ) {
    this.next_earthquake.active = false;
    this.ui->endShakeScreen();
    // if the earthquake measured more than 7 on the richter scale, tell the user about it
    if( this.next_earthquake.size > 7 ) {
      this.ui.adviser->say(_A.earthquake.ended->format(math.floor(this.next_earthquake.size)));
    }

    // set up the next earthquake date
    this->nextEarthquake();
  } else {
    var announcements = {
      "quake001.wav", "quake002.wav", "quake003.wav", "quake004.wav",
    };

    // start of warning quake
    if( this.next_earthquake.warning_timer == earthquake_warning_period ) {
      this.ui->beginShakeScreen(0.2);
      this.ui->playAnnouncement(announcements[math.random(1, #announcements)]);
    }

    // end of warning quake
    if( this.next_earthquake.warning_timer >= earthquake_warning_period - earthquake_warning_length &&
        this.next_earthquake.warning_timer - this.hours_per_tick < earthquake_warning_period - earthquake_warning_length ) {
      this.ui->endShakeScreen();
    }

    if( this.next_earthquake.warning_timer > 0 ) {
      this.next_earthquake.warning_timer = this.next_earthquake.warning_timer - this.hours_per_tick;
      // nothing more to do during inactive warning period
      if( this.next_earthquake.warning_timer < earthquake_warning_period - earthquake_warning_length ) {
        return;
      }

      // start of real earthquake
      if( this.next_earthquake.warning_timer <= 0 ) {
        this.ui->playAnnouncement(announcements[math.random(1, #announcements)]);
      }
    }

    // All earthquakes start and end small (small earthquakes never become
    // larger), so when there has been less than 2 damage applied or only
    // 2 damage remaining to be applied, move the screen with less
    // intensity than otherwise.
    if( this.next_earthquake.remaining_damage <= 2 ||
        this.next_earthquake.size - this.next_earthquake.remaining_damage <= 2 ) {
      this.ui->beginShakeScreen(0.5);
    } else {
      this.ui->beginShakeScreen(1);
    }

    // Play the earthquake sound. It has different names depending on language used though.
    if( TheApp.audio->soundExists("quake2.wav") ) {
      this.ui->playSound("quake2.wav");
    } else {
      this.ui->playSound("quake.wav");
    }

    // do not continue to damage phase while in a warning quake
    if( this.next_earthquake.warning_timer > 0 ) {
      return;
    }

    this.next_earthquake.damage_timer = this.next_earthquake.damage_timer - this.hours_per_tick;
    if( this.next_earthquake.damage_timer <= 0 ) {
      for( _, room in pairs(this.rooms) ) {
        for( object, _ in pairs(room.objects) ) {
          if( object.strength ) {
            object->machineUsed(room);
          }
        }
      }

      this.next_earthquake.remaining_damage = this.next_earthquake.remaining_damage - 1;
      this.next_earthquake.damage_timer = this.next_earthquake.damage_timer + earthquake_damage_time;
    }

    var hospital = this->getLocalPlayerHospital();
    // loop through the patients and allow the possibility for them to fall over
    for( _, patient in ipairs(hospital.patients) ) {
      if( ! patient.in_room && patient.falling_anim ) {

        // make the patients fall

        // jpirie: this is currently disabled. Calling this function
        // really screws up the action queue, sometimes the patients
        // end up with nil action queues, and sometimes the resumed
        // actions throw exceptions. Also, patients in the hospital
        // who have not yet found reception throw exceptions after
        // they visit reception. Some debugging needed here to get
        // this working.

        // patient:falling()
      }
    }
  }
}

function World::debugDisableSalaryRaise(mode) {
  this.debug_disable_salary_raise = mode;
}

var staff_to_make = {
  {class = "Doctor",       name = "doctor",       conf = "Doctors"      },
  {class = "Nurse",        name = "nurse",        conf = "Nurses"       },
  {class = "Handyman",     name = "handyman",     conf = "Handymen"     },
  {class = "Receptionist", name = "receptionist", conf = "Receptionists"},
};
function World::makeAvailableStaff(month) {
  var conf_entry = 0;
  var cfg_staff_levels = this.map.level_config.staff_levels;
  while( cfg_staff_levels[conf_entry + 1] && cfg_staff_levels[conf_entry + 1].Month <= month ) {
    ++conf_entry    ;
  }
  this.available_staff = {};
  for( _, info in ipairs(staff_to_make) ) {
    var num;
    var ind = conf_entry;
    while( ! num ) {
      assert(ind >= 0, "Staff amount " .. info.conf .. " not existent (should at least be given by base_config).");
      num = cfg_staff_levels[ind][info.conf];
      --ind    ;
    }
    var group = {};
    for( i = 1, num ) {
      group[i] = StaffProfile(this, info.class, _S.staff_class[info.name]);
      group[i]->randomise(month);
    }
    this.available_staff[info.class] = group;
  }
}

/* Register a callback for when `Humanoid`s enter or leave a given tile.
! Note that only one callback may be registered to each tile.
!param x (integer) The 1-based X co-ordinate of the tile to monitor.
!param y (integer) The 1-based Y co-ordinate of the tile to monitor.
!param object (Object) Something with an `onOccupantChange` method, which will
be called whenever a `Humanoid` enters or leaves the given tile. The method
will receive one argument (after `self`), which will be `1` for an enter event
and `-1` for a leave event.
*/
function World::notifyObjectOfOccupants(x, y, object) {
  var idx = (y - 1) * this.map.width + x;
  this.objects_notify_occupants[idx] =  object || null;
}

function World::getObjectToNotifyOfOccupants(x, y) {
  var idx = (y - 1) * this.map.width + x;
  return this.objects_notify_occupants[idx];
}

var flag_cache = {};
function World::createMapObjects(objects) {
  this.delayed_map_objects = {};
  var map = this.map.th;
  for( _, object in ipairs(objects) ) { do {
    var x, y, thob, flags = unpack(object);
    var object_id = this.object_id_by_thob[thob];
    if( ! object_id ) {
      print("Warning: Map contained object with unrecognised THOB (" .. thob .. ") at " .. x .. "," .. y);
      break; // continue
    }
    var object_type = this.object_types[object_id];
    if( ! object_type || ! object_type.supports_creation_for_map ) {
      print("Warning: Unable to create map object " .. object_id .. " at " .. x .. "," .. y);
      break; // continue
    }
    // Delay making objects which are on plots which haven't been purchased yet
    var parcel = map->getCellFlags(x, y, flag_cache).parcelId;
    if( parcel != 0 && map->getPlotOwner(parcel) == 0 ) {
      this.delayed_map_objects[{object_id, x, y, flags, "map object"}] = parcel;
    } else {
      this->newObject(object_id, x, y, flags, "map object");
    }
  } while(!( true) ); }
}

//! Change owner of a plot.
//!param parcel (int) Plot to change.
//!param owner (int) New owner (may be 0).
function World::setPlotOwner(parcel, owner) {
  this.map->setPlotOwner(parcel, owner);
  if( owner != 0 && this.delayed_map_objects ) {
    for( info, p in pairs(this.delayed_map_objects) ) {
      if( p == parcel ) {
        this->newObject(unpack(info));
        this.delayed_map_objects[info] = null;
      }
    }
  }
  this.map.th->updateShadows();
}

function World::getAnimLength(anim) {
  return this.animation_manager->getAnimLength(anim);
}

// Register a function to be called whenever a room has been deactivated (crashed or edited).
//!param callback (function) A function taking one argument: a `Room`.
function World::registerRoomRemoveCallback(callback) {
  this.room_remove_callbacks[callback] = true;
}

// Unregister a function from being called whenever a room has been deactivated (crashed or edited).
//!param callback (function) A function previously passed to
// `registerRoomRemoveCallback`.
function World::unregisterRoomRemoveCallback(callback) {
  this.room_remove_callbacks[callback] = null;
}

function World::newRoom(x, y, w, h, room_info, ...) {
  var id = #this.rooms + 1;
  // Note: Room IDs will be unique, but they may not form continuous values
  // from 1, as IDs of deleted rooms may not be re-issued for a while
  var class = room_info.class && _G[room_info.class] || Room;
  var hospital = this->getHospital(x, y);
  var room = class(x, y, w, h, id, room_info, this, hospital, ...);

  this.rooms[id] = room;
  this->clearCaches();
  return room;
}

//! Called when a room has been completely built and is ready to use.
//!param room (Room) The new room.
function World::markRoomAsBuilt(room) {
  room->roomFinished();
  var diag_disease = this.hospitals[1].disease_casebook["diag_" .. room.room_info.id];
  if( diag_disease && ! diag_disease.discovered ) {
    this.hospitals[1].disease_casebook["diag_" .. room.room_info.id].discovered = true;
  }
  for( _, entity in ipairs(this.entities) ) {
    if( entity.notifyNewRoom ) {
      entity->notifyNewRoom(room);
    }
  }
}

//! Called when a room has been deactivated (crashed or edited)
function World::notifyRoomRemoved(room) {
  this.dispatcher->dropFromQueue(room);
  for( callback in pairs(this.room_remove_callbacks) ) {
    callback(room);
  }
}

//! Clear all internal caches which are dependant upon map state / object position
function World::clearCaches() {
  this.idle_cache = {};
}

function World::getWallIdFromBlockId(block_id) {
  // Remove the transparency flag if present.
  if( this.ui.transparent_walls ) {
    block_id -=   1024;
  }
  return this.wall_id_by_block_id[block_id];
}

function World::getWallSetFromBlockId(block_id) {
  // Remove the transparency flag if present.
  if( this.ui.transparent_walls ) {
    block_id -=   1024;
  }
  return this.wall_set_by_block_id[block_id];
}

function World::getWallDirFromBlockId(block_id) {
  // Remove the transparency flag if present.
  if( this.ui.transparent_walls ) {
    block_id -=   1024;
  }
  return this.wall_dir_by_block_id[block_id];
}

var month_length = {
  31, // Jan
  28, // Feb (29 in leap years, but TH doesn't have leap years)
  31, // Mar
  30, // Apr
  31, // May
  30, // Jun
  31, // Jul
  31, // Aug
  30, // Sep
  31, // Oct
  30, // Nov
  31, // Dec
};

function World::getDate() {
  return this.game_date->monthOfYear(), this.game_date->dayOfMonth();
}

// Game speeds. The second value is the number of world clicks that pass for each
// in-game tick and the first is the number of hours to progress when this
// happens.
var tick_rates = {
  ["Pause"]              = {0, 1},
  ["Slowest"]            = {1, 9},
  ["Slower"]             = {1, 5},
  ["Normal"]             = {1, 3},
  ["Max speed"]          = {1, 1},
  ["And then some more"] = {3, 1},
  ["Speed Up"]           = {4, 1},
};

function World::speedUp() {
  this->setSpeed("Speed Up");
}

function World::previousSpeed() {
  if( this->isCurrentSpeed("Speed Up") ) {
    this->setSpeed(this.prev_speed);
  }
}

// Return if the selected speed the same as the current speed.
function World::isCurrentSpeed(speed) {
  var numerator, denominator = unpack(tick_rates[speed]);
  return this.hours_per_tick == numerator && this.tick_rate == denominator;
}

// Return the name of the current speed, relating to a key in tick_rates.
function World::getCurrentSpeed() {
  for( name, rate in pairs(tick_rates) ) {
    if( rate[1] == this.hours_per_tick && rate[2] == this.tick_rate ) {
      return name;
    }
  }
}

// Set the (approximate) number of seconds per tick.
//!param speed (string) One of: "Pause", "Slowest", "Slower", "Normal",
// "Max speed", or "And then some more".
function World::setSpeed(speed) {
  if( this->isCurrentSpeed(speed) ) {
    return;
  }
  if( speed == "Pause" ) {
    // stop screen shaking if there was an earthquake in progress
    if( this.next_earthquake.active ) {
      this.ui->endShakeScreen();
    }
    // By default actions are not allowed when the game is paused.
    this.user_actions_allowed = TheApp.config.allow_user_actions_while_paused;
  } else if( this->getCurrentSpeed() == "Pause" ) {
    this.user_actions_allowed = true;
  }

  var currentSpeed = this->getCurrentSpeed();
  if( currentSpeed != "Pause" && currentSpeed != "Speed Up" ) {
    this.prev_speed = this->getCurrentSpeed();
  }

  var was_paused = currentSpeed == "Pause";
  var numerator, denominator = unpack(tick_rates[speed]);
  this.hours_per_tick = numerator;
  this.tick_rate = denominator;

  if( was_paused ) {
    TheApp.audio->onEndPause();
  }

  // Set the blue filter according to whether the user can build or not.
  TheApp.video->setBlueFilterActive(! this.user_actions_allowed);
  return false;
}

function World::isPaused() {
  return this->isCurrentSpeed("Pause");
}

//! Dedicated function to allow unpausing by pressing 'p' again
function World::pauseOrUnpause() {
  if( ! this->isCurrentSpeed("Pause") ) {
    this->setSpeed("Pause");
  } else if( this.prev_speed ) {
    this->setSpeed(this.prev_speed);
  }
}

// Outside (air) temperatures based on climate data for Oxford, taken from
// Wikipedia. For scaling, 0 degrees C becomes 0 and 50 degrees C becomes 1
var outside_temperatures = {
   4.1  / 50, // January
   4.4  / 50, // February
   6.3  / 50, // March
   8.65 / 50, // April
  11.95 / 50, // May
  15    / 50, // June
  16.95 / 50, // July
  16.55 / 50, // August
  14.15 / 50, // September
  10.5  / 50, // October
   6.8  / 50, // November
   4.75 / 50, // December
};

//! World ticks are translated to game ticks (or hours) depending on the
// current speed of the game. There are 50 hours in a TH day.
function World::onTick() {
  if( this.map.level_number == "MAP EDITOR" ) { return; }

  if( this.tick_timer == 0 ) {
    if( this.autosave_next_tick ) {
      this.autosave_next_tick = null;
      var pathsep = package.config->sub(1, 1);
      var dir = TheApp.savegame_dir;
      if( ! dir->sub(-1, -1) == pathsep ) {
        dir = dir .. pathsep;
      }
      if( ! lfs.attributes(dir .. "Autosaves", "modification") ) {
        lfs.mkdir(dir .. "Autosaves");
      }
      var status, err = pcall(TheApp.save, TheApp, dir .. "Autosaves" .. pathsep .. "Autosave" .. this.game_date->monthOfYear() .. ".sav");
      if( ! status ) {
        print("Error while autosaving game: " .. err);
      }
    }
    if( this.game_date == Date() && ! this.ui.start_tutorial ) {
      this.ui->addWindow(UIWatch(this.ui, "initial_opening"));
      this.ui->showBriefing();
    }
    this.tick_timer = this.tick_rate;

    // if an earthquake is supposed to be going on, call the earthquake function
    if( this.next_earthquake.active ) {
      this->tickEarthquake();
    }

    var new_game_date = this.game_date->plusHours(this.hours_per_tick);
    // End of day/month/year
    if( this.game_date->dayOfMonth() != new_game_date->dayOfMonth() ) {
      for( _, hospital in ipairs(this.hospitals) ) {
        hospital->onEndDay();
      }
      this->onEndDay();
      if( this.game_date->isLastDayOfMonth() ) {
        for( _, hospital in ipairs(this.hospitals) ) {
          hospital->onEndMonth();
        }
        // Let the hospitals do what they need to do at end of month first.
        if( this->onEndMonth() ) {
          // Bail out as the game has already been ended.
          return;
        }

        if( this.game_date->isLastDayOfYear() ) {
          // It is crucial that the annual report gets to initialize before onEndYear is called.
          // Yearly statistics are reset there.
          this.ui->addWindow(UIAnnualReport(this.ui, this));
          this->onEndYear();
        }
      }
    }
    this.game_date = new_game_date;

    for( i = 1, this.hours_per_tick ) {
      for( _, hospital in ipairs(this.hospitals) ) {
        hospital->tick();
      }
      // A patient might arrive to the player hospital.
      // TODO: Multiplayer support.
      var spawn_count = this.spawn_hours[this.game_date->hourOfDay() + i - 1];
      if( spawn_count && this.hospitals[1].opened ) {
        for( _ = 1, spawn_count ) {
          this->spawnPatient();
        }
      }
      for( _, entity in ipairs(this.entities) ) {
        if( entity.ticks ) {
          this.current_tick_entity = entity;
          entity->tick();
        }
      }
      this.current_tick_entity = null;
      this.map->onTick();
      this.map.th->updateTemperatures(outside_temperatures[this.game_date->monthOfYear()],
          0.25 + this.hospitals[1].radiator_heat * 0.3);
      if( this.ui ) {
        this.ui->onWorldTick();
      }
      this.dispatcher->onTick();
    }
  }
  if( this.hours_per_tick > 0 && this.floating_dollars ) {
    for( obj in pairs(this.floating_dollars) ) {
      obj->tick();
      if( obj->isDead() ) {
        obj->setTile(null);
        this.floating_dollars[obj] = null;
      }
    }
  }
  this.tick_timer = this.tick_timer - 1;
}

function World::setEndMonth() {
  var first_day_of_next_month = Date(this.game_date->year(), this.game_date->monthOfYear() + 1);
  this.game_date = first_day_of_next_month->plusHours(-1);
}

function World::setEndYear() {
  var first_day_of_next_year = Date(this.game_date->year() + 1);
  this.game_date = first_day_of_next_year->plusHours(-1);
}

// Called immediately prior to the ingame day changing.
function World::onEndDay() {
  for( _, entity in ipairs(this.entities) ) {
    if( entity.ticks && class.is(entity, Humanoid) ) {
      this.current_tick_entity = entity;
      entity->tickDay();
    } else if( class.is(entity, Plant) ) {
      entity->tickDay();
    }
  }
  this.current_tick_entity = null;

  //check if it's time for a VIP visit
  if( this.game_date->isSameDay(this.next_vip_date) ) {
    if( #this.rooms > 0 && this.ui.hospital->hasStaffedDesk() ) {
      this.hospitals[1]->createVip();
    } else {
      this.next_vip_date = this->_generateNextVipDate();
    }
  }

  // check if it's time for an earthquake, and the user is at least on level 5
  if( this.game_date->monthOfGame() == this.next_earthquake.start_month &&
      this.game_date->dayOfMonth() == this.next_earthquake.start_day ) {
    // warn the user that an earthquake is on the way
    this.next_earthquake.active = true;
  }

  // Maybe it's time for an emergency?
  if( this.game_date->monthOfGame() == this.next_emergency_month &&
      this.game_date->dayOfMonth() == this.next_emergency_day ) {
    // Postpone it if anything clock related is already underway.
    if( this.ui->getWindow(UIWatch) ) {
      this.next_emergency_month = this.next_emergency_month + 1;
      var month_of_year = 1 + ((this.next_emergency_month - 1) % 12);
      this.next_emergency_day = math.random(1, Date(1, month_of_year)->lastDayOfMonth());
    } else {
      // Do it only for the player hospital for now. TODO: Multiplayer
      var control = this.map.level_config.emergency_control;
      if( control[0].Mean || control[0].Random ) {
        // The level uses random emergencies, so just create one.
        this.hospitals[1]->createEmergency();
      } else {
        control = control[this.next_emergency_no];
        // Find out which disease the emergency patients have.
        var disease;
        for( _, dis in ipairs(this.available_diseases) ) {
          if( dis.expertise_id == control.Illness ) {
            disease = dis;
            break;
          }
        }
        if( ! disease ) {
          // Unknown disease! Create a random one instead.
          this.hospitals[1]->createEmergency();
        } else {
          var emergency = {
            disease = disease,
            victims = math.random(control.Min, control.Max),
            bonus = control.Bonus,
            percentage = control.PercWin/100,
            killed_emergency_patients = 0,
            cured_emergency_patients = 0,
          };
          this.hospitals[1]->createEmergency(emergency);
        }
      }
    }
  }
  // Any patients tomorrow?
  this.spawn_hours = {};
  var day = this.game_date->dayOfMonth();
  if( this.spawn_dates[day] ) {
    for( _ = 1, this.spawn_dates[day] ) {
      var hour = math.random(1, Date.hoursPerDay());
      this.spawn_hours[hour] = this.spawn_hours[hour] && this.spawn_hours[hour] + 1 || 1;
    }
  }
  // TODO: Do other regular things? Such as checking if any room needs
  // staff at the moment and making plants need water.
}

function World::checkIfGameWon() {
  for( i, _ in ipairs(this.hospitals) ) {
    var res = this->checkWinningConditions(i);
    if( res.state == "win" ) {
      this->winGame(i);
    }
  }
}

// Called immediately prior to the ingame month changing.
// returns true if the game was killed due to the player losing
function World::onEndMonth() {
  // Check if a player has won the level if the year hasn't ended, if it has the
  // annual report window will perform this check when it has been closed.

  // TODO.... this is a step closer to the way TH would check.
  // What is missing is that if offer is declined then the next check should be
  // either 6 months later or at the end of month 12 and then every 6 months
  if( this.game_date->monthOfYear() % 3 == 0 && this.game_date->monthOfYear() < 12 ) {
    this->checkIfGameWon();
  }

  var local_hospital = this->getLocalPlayerHospital();
  local_hospital.population = 0.25;
  if( this.game_date->monthOfGame() >= this.map.level_config.gbv.AllocDelay ) {
    local_hospital.population = local_hospital.population * this->getReputationImpact(local_hospital);
  }

  // Also possibly change world spawn rate according to the level configuration.
  var index = 0;
  var popn = this.map.level_config.popn;
  while( popn[index] ) {
    if( popn[index].Month == this.game_date->monthOfGame() ) {
      this.monthly_spawn_increase = popn[index].Change;
      break;
    }
    ++index    ;
  }
  // Now set the new spawn rate
  this.spawn_rate = this.spawn_rate + this.monthly_spawn_increase;
  this->updateSpawnDates();

  this->makeAvailableStaff(this.game_date->monthOfGame());
  this.autosave_next_tick = true;
  for( _, entity in ipairs(this.entities) ) {
    if( entity.checkForDeadlock ) {
      this.current_tick_entity = entity;
      entity->checkForDeadlock();
    }
  }
  this.current_tick_entity = null;
}

// Called when a month ends. Decides on which dates patients arrive
// during the coming month.
function World::updateSpawnDates() {
  // Set dates when people arrive
  var no_of_spawns = math.n_random(this.spawn_rate, 2);
  // Use ceil so that at least one patient arrives (unless population = 0)
  no_of_spawns = math.ceil(no_of_spawns*this->getLocalPlayerHospital().population);
  this.spawn_dates = {};
  for( _ = 1, no_of_spawns ) {
    // We are interested in the next month, pick days from it at random.
    var day = math.random(1, this.game_date->lastDayOfMonth());
    this.spawn_dates[day] = this.spawn_dates[day] && this.spawn_dates[day] + 1 || 1;
  }
}

//! Computes the impact of hospital reputation on the spawn rate.
//! The relation between reputation and its impact is linear.
//! Returns a percentage (as a float):
//!     1% if reputation < 253
//!    60% if reputation == 400
//!   100% if reputation == 500
//!   140% if reputation == 600
//!   180% if reputation == 700
//!   300% if reputation == 1000
//!param hospital (hospital): the hospital used to compute the
//! reputation impact
function World::getReputationImpact(hospital) {
  var result = 1 + ((hospital.reputation - 500) / 250);

  // The result must be positive
  if( result <= 0 ) {
    return 0.01;
  } else {
    return result;
  }
}

// Called when it is time to determine what the
// next emergency should look like.
function World::nextEmergency() {
  var control = this.map.level_config.emergency_control;
  // Does this level use random emergencies?
  if( control && (control[0].Random || control[0].Mean) ) {
    // Support standard values for mean and variance
    var mean = control[0].Mean || 180;
    var variance = control[0].Variance || 30;
    // How many days until next emergency?
    var days = math.round(math.n_random(mean, variance));
    var emergency_date = this.game_date->plusDays(days);

    // Make it the same format as for "controlled" emergencies
    this.next_emergency_month = emergency_date->monthOfGame();
    this.next_emergency_day = emergency_date->dayOfMonth();
  } else {
    if( ! this.next_emergency_no ) {
      this.next_emergency_no = 0;
    } else {
      do {
        this.next_emergency_no = this.next_emergency_no + 1;
        // Level three is missing [5].
        if( ! control[this.next_emergency_no] &&
            control[this.next_emergency_no + 1] ) {
          this.next_emergency_no = this.next_emergency_no + 1;
        }
      } while(!( ! control[this.next_emergency_no] ||
            control[this.next_emergency_no].EndMonth >= this.game_date->monthOfGame()) );
    }

    var emergency = control[this.next_emergency_no];

    // No more emergencies?
    if( ! emergency || emergency.EndMonth == 0 ) {
      this.next_emergency_month = 0;
    } else {
      // Generate the next month and day the emergency should occur at.
      // Make sure it doesn't happen in the past.
      var start = math.max(emergency.StartMonth, this.game_date->monthOfGame());
      var next_month = math.random(start, emergency.EndMonth);
      this.next_emergency_month = next_month;
      var day_start = 1;
      if( start == emergency.EndMonth ) {
        day_start = this.game_date->dayOfMonth();
      }
      var day_end = Date(1, next_month)->lastDayOfMonth();
      this.next_emergency_day = math.random(day_start, day_end);
    }
  }
}

// Called when it is time to have another VIP
function World::nextVip() {
  this.next_vip_date = this->_generateNextVipDate();
}

// PRIVATE method to generate the next VIP date
function World::_generateNextVipDate() {
  // Support standard values for mean and variance
  var mean = 180;
  var variance = 30;
  // How many days until next vip?
  var days = math.round(math.n_random(mean, variance));
  return this.game_date->plusDays(days);
}

// Called when it is time to have another earthquake
function World::nextEarthquake() {
  this.next_earthquake = {};
  this.next_earthquake.active = false;

  var level_config = this.map.level_config;
  // check carefully that no value that we are going to use is going to be nil
  if( level_config.quake_control && level_config.quake_control[this.current_map_earthquake] &&
      level_config.quake_control[this.current_map_earthquake].Severity != 0 ) {
    // this map has rules to follow when making earthquakes, let's follow them
    var control = level_config.quake_control[this.current_map_earthquake];
    this.next_earthquake.start_month = math.random(control.StartMonth, control.EndMonth);

    // Month length of the start of the earthquake. From start to finish
    // earthquakes do not persist for >= a month so we can wrap all days
    // after the start around the month length unambiguously.
    var eqml = month_length[(this.next_earthquake.start_month % 12) + 1];
    this.next_earthquake.start_day = math.random(1, eqml);

    this.next_earthquake.size = control.Severity;
    this.next_earthquake.remaining_damage = this.next_earthquake.size;
    this.next_earthquake.damage_timer = earthquake_damage_time;
    this.next_earthquake.warning_timer = earthquake_warning_period;
    this.current_map_earthquake = this.current_map_earthquake + 1;
  }
}


//! Checks if all goals have been achieved or if the player has lost.
//! Returns a table that always contains a state string ("win", "lose" or "nothing").
//! If the state is "lose", the table also contains a reason string,
//! which corresponds to the criterion name the player lost to
//! (reputation, balance, percentage_killed) and a number limit which
//! corresponds to the limit the player passed.
//!param player_no The index of the player to check in the world's list of hospitals
function World::checkWinningConditions(player_no) {
  // If there are no goals at all, do nothing.
  if( #this.goals == 0 ) {
    return {state = "nothing"};
  }

  // Default is to win.
  // As soon as a goal that doesn't support this is found it is changed.
  var result = {state = "win"};
  var hospital = this.hospitals[player_no];

  // Go through the goals
  for( _, goal in ipairs(this.goals) ) {
    var current_value = hospital[goal.name];
    // If max_min is 1 the value must be > than the goal condition.
    // If 0 it must be < than the goal condition.
    if( goal.lose_value ) {
      var max_min = goal.max_min_lose == 1 && 1 || -1;
      // Is this a minimum/maximum that has been passed?
      // This is actually not entirely correct. A lose condition
      // for balance at -1000 will make you lose if you have exactly
      // -1000 too, but how often does that happen? Probably not more often
      // than having exactly e.g. 200 in reputation,
      // which is handled correctly.
      if( (current_value - goal.lose_value) * max_min > 0 ) {
        result.state = "lose";
        result.reason = goal.name;
        result.limit = goal.lose_value;
        break;
      }
    }
    if( goal.win_value ) {
      var max_min = goal.max_min_win == 1 && 1 || -1;
      // Special case for balance, subtract any loans!
      if( goal.name == "balance" ) {
        current_value = current_value - hospital.loan;
      }
      // Is this goal not fulfilled yet?
      if( (current_value - goal.win_value) * max_min <= 0 ) {
        result.state = "nothing";
      }
    }
  }
  return result;
}

//! Process that the given player number won the game.
//!param player_no (integer) Number of the player who just won.
function World::winGame(player_no) {
  if( player_no == 1 ) { // Player won. TODO: Needs to be changed for multiplayer
    var text = {};
    var choice_text, choice;
    var bonus_rate = math.random(4,9);
    var with_bonus = this.ui.hospital.cheated && 0 || (this.ui.hospital.player_salary * bonus_rate) / 100;
    this.ui.hospital.salary_offer = math.floor(this.ui.hospital.player_salary + with_bonus);
    if( type(this.map.level_number) == "number" || this.campaign_info ) {
      text, choice_text, choice = this->getCampaignWinningText(player_no);
    } else {
      var level_info = TheApp->readLevelFile(this.map.level_number);
      text[1] = _S.letter.dear_player->format(this.hospitals[player_no].name);
      text[2] = level_info.end_praise && level_info.end_praise || _S.letter.custom_level_completed;
      text[3] = _S.letter.return_to_main_menu;
      choice_text = _S.fax.choices.return_to_main_menu;
      choice = "return_to_main_menu";
    }
    var message = {
      {text = text[1]},
      {text = text[2]},
      {text = text[3]},
      choices = {
        {text = choice_text, choice = choice},
        {text = _S.fax.choices.decline_new_level, choice = "stay_on_level"},
      },
    };
    var /*persistable:world_win_game_message_close_callback*/ function callback () {
      var world = this.ui.app.world;
      if( world ) {
        world.hospitals[player_no].game_won = false;
        if( world->isCurrentSpeed("Pause") ) {
          world->setSpeed(world.prev_speed);
        }
      }
    }
    this.hospitals[player_no].game_won = true;
    if( this->isCurrentSpeed("Speed Up") ) {
      this->previousSpeed();
    }
    this->setSpeed("Pause");
    this.ui.app.video->setBlueFilterActive(false);
    this.ui.bottom_panel->queueMessage("information", message, null, 0, 2, callback);
    this.ui.bottom_panel->openLastMessage();
  }
}

//! Finds what text the winning fax should contain, and which choices the player has.
//!param player_no (integer) Which player that will see the message.
//!return (string, string, string) Text to show in the fax, text that accompanies
//!       the "continue"-choice the player has, and whether it is the "return_to_main_menu"
//!       choice or the "accept_new_level" choice.
function World::getCampaignWinningText(player_no) {
  var text = {};
  var choice_text, choice;
  var repeated_offer = false; // TODO whether player was asked previously to advance and declined
  var has_next = false;
  if( type(this.map.level_number) == "number" ) {
    var no = tonumber(this.map.level_number);
    has_next = no < 12 && ! TheApp.using_demo_files;
    // Standard letters 1-4:  normal
    // Standard letters 5-8:  repeated offer
    // Standard letters 9-12: last level
    var letter_idx = math.random(1, 4) + (! has_next && 8 || repeated_offer && 4 || 0);
    for( key, value in ipairs(_S.letter[letter_idx]) ) {
      text[key] = value;
    }
    text[1] = text[1]->format(this.hospitals[player_no].name);
    text[2] = text[2]->format(this.hospitals[player_no].salary_offer);
    text[3] = text[3]->format(_S.level_names[this.map.level_number + 1]);
  } else {
    var campaign_info = this.campaign_info;
    var next_level_name;
    if( campaign_info ) {
      for( i, level in ipairs(campaign_info.levels) ) {
        if( this.map.level_number == level ) {
          has_next = i < #campaign_info.levels;
          if( has_next ) {
            var next_level_info = TheApp->readLevelFile(campaign_info.levels[i + 1]);
            if( ! next_level_info ) {
              return {_S.letter.campaign_level_missing->format(campaign_info.levels[i + 1]), "", ""},
                     _S.fax.choices.return_to_main_menu,
                     "return_to_main_menu";
            }
            next_level_name = next_level_info.name;
          }
          break;
        }
      }
    }
    var level_info = TheApp->readLevelFile(this.map.level_number);
    text[1] = _S.letter.dear_player->format(this.hospitals[player_no].name);
    if( has_next ) {
      text[2] = level_info.end_praise && level_info.end_praise->format(next_level_name) || _S.letter.campaign_level_completed->format(next_level_name);
      text[3] = "";
    } else {
      text[2] = campaign_info.winning_text && campaign_info.winning_text || _S.letter.campaign_completed;
      text[3] = "";
    }
  }
  if( has_next ) {
    choice_text = _S.fax.choices.accept_new_level;
    choice = "accept_new_level";
  } else {
    choice_text = _S.fax.choices.return_to_main_menu;
    choice = "return_to_main_menu";
  }
  return text, choice_text, choice;
}

//! Cause the player with the player number player_no to lose.
//!param player_no (number) The number of the player which should lose.
//!param reason (string) [optional] The name of the criterion the player lost to.
//!param limit (number) [optional] The number the player went over/under which caused him to lose.
function World::loseGame(player_no, reason, limit) {
  if( player_no == 1 ) { // TODO: Multiplayer
    this.ui.app.moviePlayer->playLoseMovie();
    var message = {_S.information.level_lost[1]};
    if( reason ) {
      message[2] = _S.information.level_lost[2];
      message[3] = _S.information.level_lost[reason]->format(limit);
    } else {
      message[2] = _S.information.level_lost["cheat"];
     }
    this.ui.app->loadMainMenu(message);
  }
}

// Called immediately prior to the ingame year changing.
function World::onEndYear() {
  for( _, hospital in ipairs(this.hospitals) ) {
    hospital->onEndYear();
  }
  // This is done here instead of in onEndMonth so that the player gets
  // the chance to receive money or reputation from trophies and awards first.
  for( i, _ in ipairs(this.hospitals) ) {
    var res = this->checkWinningConditions(i);
    if( res.state == "lose" ) {
      this->loseGame(i, res.reason, res.limit);
      if( i == 1 ) {
        return true;
      }
    }
  }
}

// Calculate the distance of the shortest path (along passable tiles) between
// the two given map tiles. This operation is commutative (swapping (x1, y1)
// with (x2, y2) has no effect on the result) if both tiles are passable.
//!param x1 (integer) X-cordinate of first tile's Lua tile co-ordinates.
//!param y1 (integer) Y-cordinate of first tile's Lua tile co-ordinates.
//!param x2 (integer) X-cordinate of second tile's Lua tile co-ordinates.
//!param y2 (integer) Y-cordinate of second tile's Lua tile co-ordinates.
//!return (integer, boolean) The distance of the shortest path, or false if
// there is no path.
function World::getPathDistance(x1, y1, x2, y2) {
  return this.pathfinder->findDistance(x1, y1, x2, y2);
}

function World::getPath(x, y, dest_x, dest_y) {
  return this.pathfinder->findPath(x, y, dest_x, dest_y);
}

function World::getIdleTile(x, y, idx) {
  var cache_idx = (y - 1) * this.map.width + x;
  var cache = this.idle_cache[cache_idx];
  if( ! cache ) {
    cache = {
      x = {},
      y = {},
    };
    this.idle_cache[cache_idx] = cache;
  }
  if( ! cache.x[idx] ) {
    var ix, iy = this.pathfinder->findIdleTile(x, y, idx);
    if( ! ix ) {
      return ix, iy;
    }
    cache.x[idx] = ix;
    cache.y[idx] = iy;
  }
  return cache.x[idx], cache.y[idx];
}

/*
This function checks if a tile has no entity on it and (optionally) if it is not
in a room.
!param x (integer) the queried tile's x coordinate.
!param y (integer) the queried tile's y coordinate.
!param not_in_room (boolean) If set, also check the tile is not in a room.
!return (boolean) whether all checks hold.
--*/
function World::isTileEmpty(x, y, not_in_room) {
  if( #this.entity_map->getHumanoidsAtCoordinate(x, y) != 0 ||
      #this.entity_map->getObjectsAtCoordinate(x, y) != 0 ) {
    return false;
  }
  if( not_in_room ) {
    return this->getRoom(x, y) == null;
  }
  return true;
}

function World::getFreeBench(x, y, distance) {
  var bench, rx, ry, bench_distance;
  var object_type = this.object_types.bench;
  x, y, distance = math.floor(x), math.floor(y), math.ceil(distance);
  this.pathfinder->findObject(x, y, object_type.thob, distance, function(xpos, ypos, d, dist) {
    var b = this->getObject(xpos, ypos, "bench");
    if( b && ! b.user && ! b.reserved_for ) {
      var orientation = object_type.orientations[b.direction];
      if( orientation.pathfind_allowed_dirs[d] ) {
        rx = xpos + orientation.use_position[1];
        ry = ypos + orientation.use_position[2];
        bench = b;
        bench_distance = dist;
        return true;
      }
    }
  });
  return bench, rx, ry, bench_distance;
}

//! Checks whether the given tile is part of a nearby object (walkable tiles
//  count as part of the object)
//!param x X position of the given tile.
//!param y Y position of the given tile.
//!param distance The number of tiles away from the tile to search.
//!return (boolean) Whether the tile is part of a nearby object.
function World::isTilePartOfNearbyObject(x, y, distance) {
  for( o in pairs(this->findAllObjectsNear(x, y, distance)) ) {
    for( _, xy in ipairs(o->getWalkableTiles()) ) {
      if( xy[1] == x && xy[2] == y ) {
        return true;
      }
    }
  }
  return false;
}

// Returns a set of all objects near the given position but if supplied only of the given object type.
//!param x The x-coordinate at which to originate the search
//!param y The y-coordinate
//!param distance The number of tiles away from the origin to search
//!param object_type_name The name of the objects that are being searched for
function World::findAllObjectsNear(x, y, distance, object_type_name) {
  if( ! distance ) {
    // Note that regardless of distance, only the room which the humanoid is in
    // is searched (or the corridor if the humanoid is not in a room).
    distance = 2**30;
  }
  var objects = {};
  var thob = 0;
  if( object_type_name ) {
    var obj_type = this.object_types[object_type_name];
    if( ! obj_type ) {
      error("Invalid object type name: " .. object_type_name);
    }
    thob = obj_type.thob;
  }

  var callback = function(xpos, ypos, d) {
    var obj = this->getObject(xpos, ypos, object_type_name);
    if( obj ) {
      objects[obj] = true;
    }
  };
  this.pathfinder->findObject(x, y, thob, distance, callback);
  return objects;
}

/* Find all objects of the given type near the humanoid.
Note that regardless of distance, only the room which the humanoid is in
is searched (or the corridor if the humanoid is not in a room).

When no callback is specified then the first object found is returned,
along with its usage tile position. This may return an object already being
used - if you want to find an object not in use (in order to use it),
then call findFreeObjectNearToUse instead.

!param humanoid The humanoid to search around
!param object_type_name The objects to search for
!param distance Maximum L1 distance to search from humanoid. If nil then
       everywhere in range will be searched.
!param callback Function to call for each result. If it returns true then
       the search will be ended.
--*/
function World::findObjectNear(humanoid, object_type_name, distance, callback) {
  if( ! distance ) {
    distance = 2**30;
  }
  var obj, ox, oy;
  if( ! callback ) {
    // The default callback returns the first object found
    callback = function(x, y, d) {
      obj = this->getObject(x, y, object_type_name);
      var orientation = obj.object_type.orientations;
      if( orientation ) {
        orientation = orientation[obj.direction];
        if( ! orientation.pathfind_allowed_dirs[d] ) {
          return;
        }
        x = x + orientation.use_position[1];
        y = y + orientation.use_position[2];
      }
      ox = x;
      oy = y;
      return true;
    };
  }
  var thob = 0;
  if( type(object_type_name) == "table" ) {
    var original_callback = callback;
    callback = function(x, y, ...) {
      var cb_obj = this->getObject(x, y, object_type_name);
      if( cb_obj ) {
        return original_callback(x, y, ...);
      }
    };
  } else if( object_type_name != null ) {
    var obj_type = this.object_types[object_type_name];
    if( ! obj_type ) {
      error("Invalid object type name: " .. object_type_name);
    }
    thob = obj_type.thob;
  }
  this.pathfinder->findObject(humanoid.tile_x, humanoid.tile_y, thob, distance,
    callback);
  // These return values are only relevant for the default callback - are nil
  // for custom callbacks
  return obj, ox, oy;
}

function World::findFreeObjectNearToUse(humanoid, object_type_name, which, current_object) {
  // If which == nil or false, then the nearest object is taken.
  // If which == "far", then the furthest object is taken.
  // If which == "near", then the nearest object is taken with 50% probability, the second nearest with 25%, and so on
  // Other values for which may be added in the future.
  // Specify current_object if you want to exclude the currently used object from the search
  var object, ox, oy;
  this->findObjectNear(humanoid, object_type_name, null, function(x, y, d) {
    var obj = this->getObject(x, y, object_type_name);
    if( obj.user || (obj.reserved_for && obj.reserved_for != humanoid) || (current_object && obj == current_object) ) {
      return;
    }
    var orientation = obj.object_type.orientations;
    if( orientation ) {
      orientation = orientation[obj.direction];
      if( ! orientation.pathfind_allowed_dirs[d] ) {
        return;
      }
      x = x + orientation.use_position[1];
      y = y + orientation.use_position[2];
    }
    object = obj;
    ox = x;
    oy = y;
    if( which == "far" ) {
      // just take the last found object, so don't ever abort
    } else if( which == "near" ) {
      // abort at each item with 50% probability
      var chance = math.random(1, 2);
      if( chance == 1 ) {
        return true;
      }
    } else {
      // default: return at the first found item
      return true;
    }
  });
  return object, ox, oy;
}

function World::findRoomNear(humanoid, room_type_id, distance, mode) {
  // If mode == "nearest" (or nil), the nearest room is taken
  // If mode == "advanced", prefer a near room, but also few patients and fulfilled staff criteria
  var room;
  var score;
  if( ! mode ) {
    mode = "nearest"; // default mode
  }
  if( ! distance ) {
    distance = 2**30;
  }
  for( _, r in pairs(this.rooms) ) { do {
    if( r.built && (! room_type_id || r.room_info.id == room_type_id) && r.is_active ) {
      var x, y = r->getEntranceXY(false);
      var d = this->getPathDistance(humanoid.tile_x, humanoid.tile_y, x, y);
      if( ! d || d > distance ) {
        break; // continue
      }
      var this_score = d;
      if( mode == "advanced" ) {
        this_score = this_score + r->getUsageScore();
      }
      if( ! score || this_score < score ) {
        score = this_score;
        room = r;
      }
    }
  } while(!( true) ); }
  return room;
}

//! Setup an animated floating money amount above a patient.
//!param patient Patient to float above.
//!param amount Amount of money to display.
function World::newFloatingDollarSign(patient, amount) {
  if( ! this.floating_dollars ) {
    this.floating_dollars = {};
  }
  if( this.free_build_mode ) {
    return;
  }
  var spritelist = TH.spriteList();
  spritelist->setPosition(-17, -60);
  spritelist->setSpeed(0, -1)->setLifetime(100);
  spritelist->setSheet(TheApp.gfx->loadSpriteTable("Data", "Money01V"));
  spritelist->append(1, 0, 0);
  var len = #("%i")->format(amount);
  var xbase = math.floor(10.5 + (20 - 5 * len) / 2);
  for( i = 1, len ) {
    var digit = amount % 10;
    amount = (amount - digit) / 10;
    spritelist->append(2 + digit, xbase + 5 * (len - i), 5);
  }
  spritelist->setTile(this.map.th, patient.tile_x, patient.tile_y);

  this.floating_dollars[spritelist] = true;
}

function World::newEntity(class, animation) {
  var th = TH.animation();
  th->setAnimation(this.anims, animation);
  var entity = _G[class](th);
  this.entities[#this.entities + 1] = entity;
  entity.world = this;
  return entity;
}

function World::destroyEntity(entity) {
  for( i, e in ipairs(this.entities) ) {
    if( e == entity ) {
      table.remove(this.entities, i);
      break;
    }
  }
  entity->onDestroy();
}

function World::newObjectType(new_object) {
  this.object_types[new_object.id] = new_object;
}

//! Creates a new object by finding the object_type from the "id" variable and
//  calls its class constructor.
//!param id (string) The unique id of the object to be created.
//!return The created object.
function World::newObject(id, ...) {
  var object_type = this.object_types[id];
  var entity;
  if( object_type.class ) {
    entity = _G[object_type.class](this, object_type, ...);
  } else if( object_type.default_strength ) {
    entity = Machine(this, object_type, ...);
    // Tell the player if there is no handyman to take care of the new machinery.
    if( ! this.hospitals[1]->hasStaffOfCategory("Handyman") ) {
      this.ui.adviser->say(_A.staff_advice.need_handyman_machines);
    }
  } else {
    entity = Object(this, object_type, ...);
  }
  this->objectPlaced(entity, id);
  return entity;
}

function World::canNonSideObjectBeSpawnedAt(x, y, objects_id, orientation, spawn_rooms_id, player_id) {
  var object = this.object_types[objects_id];
  var objects_footprint = object.orientations[orientation].footprint;
  for( _, tile in ipairs(objects_footprint) ) {
    var tiles_world_x = x + tile[1];
    var tiles_world_y = y + tile[2];
    if( ! this->isOnMap(tiles_world_x, tiles_world_y) ) {
      return false;
    }

    if( ! this->willObjectsFootprintTileBeWithinItsAllowedRoomIfLocatedAt(x, y, object, spawn_rooms_id).within_room ) {
      return false;
    }

    if( ! this->isFootprintTileBuildableOrPassable(x, y, tile, objects_footprint, "buildable", player_id) ) {
      return false;
    }
  }
  return ! this->wouldNonSideObjectBreakPathfindingIfSpawnedAt(x, y, object, orientation, spawn_rooms_id);
}

//! Test whether the given coordinate is on the map.
//!param x (int) X position of the coordinate to test.
//!param y (int) Y position of the coordinate to test.
//!return (boolean) Whether the provided position is on the map.
function World::isOnMap(x, y) {
  return x >= 1 && x <= this.map.width && y >= 1 && y <= this.map.height;
}

//-
// @param allowed_rooms_id_parameter Should be nil when the object is allowed to be placed in any room.
// @return {within_room, roomId}
//-
function World::willObjectsFootprintTileBeWithinItsAllowedRoomIfLocatedAt(x, y, object, allowed_rooms_id_parameter) {
  var xy_rooms_id = this.map.th->getCellFlags(x, y, {}).roomId;

  if( allowed_rooms_id_parameter ) {
    return {within_room = allowed_rooms_id_parameter == xy_rooms_id, roomId = allowed_rooms_id_parameter};
  } else if( xy_rooms_id == 0 ) {
    return {within_room = object.corridor_object != null, roomId = xy_rooms_id};
  } else {
    for( _, additional_objects_name in pairs(this.rooms[xy_rooms_id].room_info.objects_additional) ) {
      if( TheApp.objects[additional_objects_name].thob == object.thob ) {
        return {within_room = true, roomId = xy_rooms_id};
      }
    }
    for( needed_objects_name, _ in pairs(this.rooms[xy_rooms_id].room_info.objects_needed) ) {
      if( TheApp.objects[needed_objects_name].thob == object.thob ) {
        return {within_room = true, roomId = xy_rooms_id};
      }
    }
    return {within_room = false, roomId = xy_rooms_id};
  }
}

//-
// A footprint tile will either need to be buildable or passable so this function
// checks if its buildable/passable using the tile's appropriate flag and then returns this
// flag's boolean value or false if the tile isn't valid.
//-
function World::isFootprintTileBuildableOrPassable(x, y, tile, footprint, requirement_flag, player_id) {
  var function isTileValid(xpos, ypos, complete_cell, flags, flag_name, need_side) {
    if( complete_cell || need_side ) {
      return flags[flag_name];
    }
    for( _, fp_tile in ipairs(footprint) ) {
      if( fp_tile[1] == xpos && fp_tile[2] == ypos ) {
        return flags[flag_name];
      }
    }
    return true;
  }

  var direction_parameters = {
      north = { x = 0, y = -1, buildable_flag = "buildableNorth", passable_flag = "travelNorth", needed_side = "need_north_side"},
      east = { x = 1, y = 0, buildable_flag =  "buildableEast", passable_flag = "travelEast", needed_side = "need_east_side"},
      south = { x = 0, y = 1, buildable_flag = "buildableSouth", passable_flag = "travelSouth", needed_side = "need_south_side"},
      west = { x = -1, y = 0, buildable_flag = "buildableWest", passable_flag = "travelWest", needed_side = "need_west_side"}
    };
  var flags = {};
  var requirement_met = this.map.th->getCellFlags(x, y, flags)[requirement_flag] &&
      (player_id == 0 || player_id == flags.owner);

  if( requirement_met ) {
    // For each direction check that the tile is valid:
    for( _, direction in pairs(direction_parameters) ) {
      var x1, y1 = tile[1] + direction["x"], tile[2] + direction["y"];
      if( ! isTileValid(x1, y1, tile.complete_cell, flags, direction["buildable_flag"], tile[direction["needed_side"]]) ) {
        return false;
      }
    }
    return true;
  } else {
    return false;
  }
}

//-
// Check that pathfinding still works, i.e. that placing the object
// wouldn't disconnect one part of the hospital from another. To do
// this, we provisionally mark the footprint as unpassable (as it will
// become when the object is placed), and then check that the cells
// surrounding the footprint have not had their connectedness changed.
//-
function World::wouldNonSideObjectBreakPathfindingIfSpawnedAt(x, y, object, objects_orientation, spawn_rooms_id) {
  var objects_footprint = object.orientations[objects_orientation].footprint;
  var map = this.map.th;

  var function setFootprintTilesPassable(passable) {
    for( _, tile in ipairs(objects_footprint) ) {
      if( ! tile.only_passable ) {
        map->setCellFlags(x + tile[1], y + tile[2], {passable = passable});
      }
    }
  }

  var function isIsolated(xpos, ypos) {
    setFootprintTilesPassable(false);
    var result = ! this.pathfinder->isReachableFromHospital(xpos, ypos);
    setFootprintTilesPassable(true);
    return result;
  }

  var all_good = true;

  //1. Find out which footprint tiles are passable now before this function makes some unpassable
  //during its test:
  var tiles_passable_flags = {};
  for( _, tile in ipairs(objects_footprint) ) {
    table.insert(tiles_passable_flags, map->getCellFlags(x + tile[1], y + tile[2], {}).passable);
  }

  //2. Find out which tiles adjacent to the footprint would become isolated:
  setFootprintTilesPassable(false);
  var prev_x, prev_y;
  for( _, tile in ipairs(object.orientations[objects_orientation].adjacent_to_solid_footprint) ) {
    var xpos = x + tile[1];
    var ypos = y + tile[2];
    var flags = {};
    if( map->getCellFlags(xpos, ypos, flags).roomId == spawn_rooms_id && flags.passable ) {
      if( prev_x ) {
        if( ! this.pathfinder->findDistance(xpos, ypos, prev_x, prev_y) ) {
          // There is no route between the two map nodes. In most cases,
          // this means that connectedness has changed, though there is
          // one rare situation where the above test is insufficient. If
          // (xpos, ypos) is a passable but isolated node outside the hospital
          // and (prev_x, prev_y) is in the corridor, then the two will
          // not be connected now, but critically, neither were they
          // connected before.
          if( ! isIsolated(xpos, ypos) ) {
            if( ! isIsolated(prev_x, prev_y) ) {
              all_good = false;
              break;
            }
          } else {
            xpos = prev_x;
            ypos = prev_y;
          }
        }
      }
      prev_x = xpos;
      prev_y = ypos;
    }
  }

  // 3. For each footprint tile passable flag set to false by step 2 undo this change:
  for( tiles_index, tile in ipairs(objects_footprint) ) {
    map->setCellFlags(x + tile[1], y + tile[2], {passable = tiles_passable_flags[tiles_index]});
  }

  return ! all_good;
}

//! Notifies the world that an object has been placed, notifying
//  interested entities in the vicinity of the new arrival.
//!param entity (Entity) The entity that was just placed.
//!param id (string) That entity's id.
function World::objectPlaced(entity, id) {
  // If id is not supplied, we can use the entities internal id if it exists
  // This is so the bench check below works
  // see place_object.lua:UIPlaceObjects:placeObject for call w/o id --cgj
  if( ! id && entity.object_type.id ) {
    id = entity.object_type.id;
  }

  this.entities[#this.entities + 1] = entity;
  // If it is a bench we're placing, notify queueing patients in the vicinity
  if( id == "bench" && entity.tile_x && entity.tile_y ) {
    var notify_distance = 6;
    var w, h = this.map.th->size();
    for( tx = math.max(1, entity.tile_x - notify_distance), math.min(w, entity.tile_x + notify_distance) ) {
      for( ty = math.max(1, entity.tile_y - notify_distance), math.min(h, entity.tile_y + notify_distance) ) {
        for( _, patient in ipairs(this.entity_map->getHumanoidsAtCoordinate(tx, ty)) ) {
          if( class.is(patient, Patient) ) {
            patient->notifyNewObject(id);
          }
        }
      }
    }
  }
  if( id == "reception_desk" ) {
    if( ! this.ui.start_tutorial &&
        ! this.hospitals[1]->hasStaffOfCategory("Receptionist") ) {
      // TODO: Will not work correctly for multiplayer
      this.ui.adviser->say(_A.room_requirements.reception_need_receptionist);
    } else if( this.hospitals[1]->hasStaffOfCategory("Receptionist") &&
        this.object_counts["reception_desk"] == 1 &&
        ! this.hospitals[1].receptionist_msg && this.game_date->monthOfGame() > 3 ) {
      this.ui.adviser->say(_A.warnings.no_desk_5);
      this.hospitals[1].receptionist_msg = true;
    }
  }
  // If it is a plant it might be advisable to hire a handyman
  if( id == "plant" && ! this.hospitals[1]->hasStaffOfCategory("Handyman") ) {
    this.ui.adviser->say(_A.staff_advice.need_handyman_plants);
  }
  if( id == "gates_to_hell" ) {
    entity->playEntitySounds("LAVA00*.WAV", {0,1350,1150,950,750,350},
        {0,1450,1250,1050,850,450}, 40);
    entity->setTimer(entity.world->getAnimLength(2550),
                    /*persistable:lava_hole_spawn_animation_end*/
                    function(anim_entity) {
                      anim_entity->setAnimation(1602);
                    });
    entity->setAnimation(2550);
  }
}

//! Notify the world of an object being removed from a tile
//! See also `World:addObjectToTile`
//!param object (Object) The object being removed.
//!param x (integer) The X-coordinate of the tile which the object was on
//!param y (integer) The Y-coordinate of the tile which the object was on
function World::removeObjectFromTile(object, x, y) {
  var index = (y - 1) * this.map.width + x;
  var objects = this.objects[index];
  var thob = object.object_type.thob;
  if( objects ) {
    for( k, v in ipairs(objects) ) {
      if( v == object ) {
        table_remove(objects, k);
        this.map.th->removeObjectType(x, y, thob);
        var count_cat = object.object_type.count_category;
        if( count_cat ) {
          this.object_counts[count_cat] = this.object_counts[count_cat] - 1;
        }
        return true;
      }
    }
  }
  return false;
}

//! Notify the world of a new object being placed somewhere in the world
//! See also `World:removeObjectFromTile`
//!param object (Object) The object being placed
//!param x (integer) The X-coordinate of the tile being placed upon
//!param y (integer) The Y-coordinate of the tile being placed upon
function World::addObjectToTile(object, x, y) {
  var index = (y - 1) * this.map.width + x;
  var objects = this.objects[index];
  if( objects ) {
    this.map.th->setCellFlags(x, y, {thob = object.object_type.thob});
    objects[#objects + 1] = object;
  } else {
    objects = {object};
    this.objects[index] = objects;
    this.map.th->setCellFlags(x, y, {thob = object.object_type.thob});
  }
  var count_cat = object.object_type.count_category;
  if( count_cat ) {
    this.object_counts[count_cat] = this.object_counts[count_cat] + 1;
  }
  return true;
}

//! Retrieve all objects from a given position.
//!param x (int) X position of the object to retrieve.
//!param y (int) Y position of the object to retrieve.
function World::getObjects(x, y) {
  var index = (y - 1) * this.map.width + x;
  return this.objects[index];
}

//! Retrieve one object from a given position.
//!param x (int) X position of the object to retrieve.
//!param y (int) Y position of the object to retrieve.
//!param id Id to search, nil gets first object, string gets first object with
//! that id, set of strings gets first object that matches an entry in the set.
//!return (Object or nil) The found object, or nil if the object is not found.
function World::getObject(x, y, id) {
  var objects = this->getObjects(x, y);
  if( objects ) {
    if( ! id ) {
      return objects[1];
    } else if( type(id) == "table" ) {
      for( _, obj in ipairs(objects) ) {
        if( id[obj.object_type.id] ) {
          return obj;
        }
      }
    } else {
      for( _, obj in ipairs(objects) ) {
        if( obj.object_type.id == id ) {
          return obj;
        }
      }
    }
  }
  return; // nil
}

//! Remove all cleanable litter from a given tile.
//!param x (int) X position of the tile to clean.
//!param y (int) Y position of the tile to clean.
function World::removeAllLitter(x, y) {
  var litters = {};
  var objects = this->getObjects(x, y);
  if( ! objects ) { return; }

  for( _, obj in ipairs(objects) ) {
    if( obj.object_type.id == "litter" && obj->isCleanable() ) {
      litters[#litters + 1] = obj;
    }
  }
  for( _, litter in ipairs(litters) ) { litter->remove(); }
}

//! Prepare all tiles of the footprint for build of an object.
//!param object_footprint Footprint of the object being build.
//!param x (int) X position of the object
//!param y (int) Y position of the object
function World::prepareFootprintTilesForBuild(object_footprint, x, y) {
  var hospital = this->getLocalPlayerHospital();

  for( _, tile in ipairs(object_footprint) ) {
    if( tile.complete_cell || ! (tile.passable || tile.only_passable) ) {
      this->removeAllLitter(x + tile[1], y + tile[2]);
      hospital->removeRatholeXY(x + tile[1], y + tile[2]);
    }
  }
}

//! Prepare all tiles in the given rectangle for building a room.
//!param x (int) Start x position of the area.
//!param y (int) Start y position of the area.
//!param w (int) Number of tiles in x direction.
//!param h (int) Number of tiles in y direction.
function World::prepareRectangleTilesForBuild(x, y, w, h) {
  var hospital = this->getLocalPlayerHospital();

  --x    ;
  --y    ;
  for( dx = 1, w ) {
    for( dy = 1, h ) {
      this->removeAllLitter(x + dx, y + dy);
      if( dx == 1 || dx == w || dy == 1 || dy == h ) { hospital->removeRatholeXY(x + dx, y + dy); }
    }
  }
}

//! Get the room at a given tile location.
//!param x (int) X position of the queried tile.
//!param y (int) Y position of the queried tile.
//!return (Room) Room of the tile, or 'nil'.
function World::getRoom(x, y) {
  return this.rooms[this.map->getRoomId(x, y)];
}

//! Get the hospital at a given tile location.
//!param x (int) X position of the queried tile.
//!param y (int) Y position of the queried tile.
//!return (Hospital) Hospital at the given location or 'nil'.
function World::getHospital(x, y) {
  var th = this.map.th;

  var flags = th->getCellFlags(x, y);
  if( ! flags.hospital ) { return null; }
  return this.hospitals[flags.owner];
}

//! Returns localized name of the room, internal required staff name
// and localized name of staff required.
function World::getRoomNameAndRequiredStaffName(room_id) {
  var room_name, required_staff, staff_name;
  for( _, room in ipairs(TheApp.rooms) ) {
    if( room.id == room_id ) {
      room_name = room.name;
      required_staff = room.required_staff;
    }
  }
  for( key, _ in pairs(required_staff) ) {
    staff_name = key;
  }
  required_staff = staff_name; // This is the "programmatic" name of the staff.
  if( staff_name == "Nurse" ) {
    staff_name = _S.staff_title.nurse;
  } else if( staff_name == "Psychiatrist" ) {
    staff_name = _S.staff_title.psychiatrist;
  } else if( staff_name == "Researcher" ) {
    staff_name = _S.staff_title.researcher;
  } else if( staff_name == "Surgeon" ) {
    staff_name = _S.staff_title.surgeon;
  } else if( staff_name == "Doctor" ) {
    staff_name = _S.staff_title.doctor;
  }
  return room_name, required_staff, staff_name;
}

//! Append a message to the game log.
//!param message (string) The message to add.
function World::gameLog(message) {
  this.game_log[#this.game_log + 1] = message;
  // If in debug mode also show it in the command prompt
  if( TheApp.config.debug ) {
    print(message);
  }
}

//! Dump the contents of the game log into a file.
// This is automatically done on each error.
function World::dumpGameLog() {
  var config_path = TheApp.command_line["config-file"] || "";
  var pathsep = package.config->sub(1, 1);
  config_path = config_path->match("^(.-)[^" .. pathsep .. "]*$");
  var gamelog_path = config_path .. "gamelog.txt";
  var fi, err = io.open(gamelog_path, "w");
  if( fi ) {
    for( _, str in ipairs(this.game_log) ) {
      fi->write(str .. "\n");
    }
    fi->close();
  } else {
    print("Warning: Cannot dump game log: " .. tostring(err));
  }
}

//! Because the save file only saves one thob per tile if they are more that information
// will be lost. To solve this after a load we need to set again all the thobs on each tile.
function World::resetAnimations() {
  // Erase entities from the map if they want.
  for( _, entity in ipairs(this.entities) ) {
    entity->eraseObject();
  }
  // Add them again.
  for( _, entity in ipairs(this.entities) ) {
    entity->resetAnimation();
  }
}

//! Let the world react to and old save game. First it gets the chance to
// do things for itself, and then it calls corresponding functions for
// the hospitals, entities and rooms in that order.
//!param old The old version of the save game.
//!param new The current version of the save game format.
function World::afterLoad(old, new) {

  if( ! this.original_savegame_version ) {
    this.original_savegame_version = old;
  }
  // If the original save game version is considerably lower than the current, warn the player.
  if( new - 20 > this.original_savegame_version ) {
    this.ui->addWindow(UIInformation(this.ui, {_S.information.very_old_save}));
  }
  // insert global compatibility code here
  if( old < 4 ) {
    this.room_built = {};
  }
  if( old < 6 ) {
    // Calculate hospital value

    // Initial value
    var value = this.map.parcelTileCounts[this.hospitals[1]->getPlayerIndex()] * 25 + 20000;

    // Add room values
    for( _, room in pairs(this.rooms) ) {
      var valueChange = room.room_info.build_cost;

      // Subtract values of objects in rooms to avoid calculating those object values twice
      for( obj, num in pairs(room.room_info.objects_needed) ) {
        valueChange = valueChange - num * TheApp.objects[obj].build_cost;
      }
      value +=   valueChange;
    }

    // Add up all object values
    for( _, object in ipairs(this.entities) ) {
        if( class.is(object, Object) && object.object_type.build_cost ) {
          value = value + object.object_type.build_cost;
        }
    }

    this.hospitals[1].value = value;
  }

  if( old < 7 ) {
    this.level_criteria = local_criteria_variable;
    this->determineWinningConditions();
  }
  if( old < 10 ) {
    this.object_counts = {
      extinguisher = 0,
      radiator = 0,
      plant = 0,
      general = 0,
    };
    for( _, obj_list in pairs(this.objects) ) {
      for( _, obj in ipairs(obj_list) ) {
        var count_cat = obj.object_type.count_category;
        if( count_cat ) {
          this.object_counts[count_cat] = this.object_counts[count_cat] + 1;
        }
      }
    }
  }
  if( old < 43 ) {
    this.object_counts.reception_desk = 0;
    for( _, obj_list in pairs(this.objects) ) {
      for( _, obj in ipairs(obj_list) ) {
        var count_cat = obj.object_type.count_category;
        if( count_cat && count_cat == "reception_desk" ) {
          this.object_counts[count_cat] = this.object_counts[count_cat] + 1;
        }
      }
    }
  }
  if( old < 47 ) {
    this.object_counts.bench = 0;
    for( _, obj_list in pairs(this.objects) ) {
      for( _, obj in ipairs(obj_list) ) {
        var count_cat = obj.object_type.count_category;
        if( count_cat && count_cat == "bench" ) {
          this.object_counts[count_cat] = this.object_counts[count_cat] + 1;
        }
      }
    }
  }
  if( old < 12 ) {
    this.animation_manager = TheApp.animation_manager;
    this.anim_length_cache = null;
  }
  if( old < 16 ) {
    this.ui->addKeyHandler("+", this, this.adjustZoom,  1);
    this.ui->addKeyHandler("-", this, this.adjustZoom, -1);
  }
  if( old < 17 ) {
    // Added another object
    var pathsep = package.config->sub(1, 1);
    var _, shield = pcall(corsixth.require, "objects" .. pathsep .. "radiation_shield");
    var _, shield_b = pcall(corsixth.require, "objects" .. pathsep .. "radiation_shield_b");
    shield.slave_type = shield_b;
    shield.slave_type.master_type = shield;
    Object.processTypeDefinition(shield);
    Object.processTypeDefinition(shield_b);

    this.object_id_by_thob[shield.thob] = shield.id;
    this.object_id_by_thob[shield_b.thob] = shield_b.id;
    this.object_types[shield.id] = shield;
    this.object_types[shield_b.id] = shield_b;
    this.ui.app.objects[shield.id] = shield;
    this.ui.app.objects[shield_b.id] = shield_b;
    this.ui.app.objects[#this.ui.app.objects + 1] = shield;
    this.ui.app.objects[#this.ui.app.objects + 1] = shield_b;
  }
  if( old < 27 ) {
    // Add callsDispatcher
    this.dispatcher = CallsDispatcher(this);
  }
  if( old < 30 ) {
    this->nextEmergency();
  }
  if( old < 31 ) {
    this.hours_per_day = 50;
    this->setSpeed("Normal");
  }
  if( old < 36 ) {
    this->determineWinningConditions();
  }
  if( old < 37 ) {
    // Spawn rate is taken from level files now.
    // Make sure that all config values are present.
    if( ! this.map.level_config.popn ) {
      this.map.level_config.popn = {
        [0] = {Change = 3, Month = 0},
        [1] = {Change = 1, Month = 1},
      };
    }
    if( ! this.map.level_config.gbv.AllocDelay ) {
      this.map.level_config.gbv.AllocDelay = 3;
    }
    var index = 0;
    var popn = this.map.level_config.popn;
    this.spawn_rate = popn[index].Change;
    this.monthly_spawn_increase = this.spawn_rate;

    // Bring the spawn rate "up to speed".
    for( month = 1, this.month + (this.year-1)*12 ) {
      // Check if the next entry should be used.
      while( popn[index + 1] && month >= popn[index + 1].Month ) {
        ++index    ;
      }
      this.monthly_spawn_increase = popn[index].Change;
      this.spawn_rate = this.spawn_rate + this.monthly_spawn_increase;
    }
    this.spawn_hours = {};
    this.spawn_dates = {};
    this->updateSpawnDates();
  }
  if( old < 45 ) {
    this->nextVip();
  }
  if( old < 52 ) {
    // Litter was not properly removed from the world.
    for( i = #this.entities, 1, -1 ) {
      if( class.is(this.entities[i], Litter) ) {
        if( ! this.entities[i].tile_x ) {
          this->destroyEntity(this.entities[i]);
        }
      }
    }
  }
  if( old < 53 ) {
    this.current_map_earthquake = 0;
    // It may happen that the current game has gone on for a while
    if( this.map.level_config.quake_control ) {
      while( true ) {
        if( this.map.level_config.quake_control[this.current_map_earthquake] &&
            this.map.level_config.quake_control[this.current_map_earthquake] != 0 ) {
          // Check to see if the start month has passed
          var control = this.map.level_config.quake_control[this.current_map_earthquake];
          if( control.StartMonth <= this.month + 12 * (this.year - 1) ) {
            // Then check the next one
            this.current_map_earthquake = this.current_map_earthquake + 1;
          } else {
            // We found an earthquake coming in the future!
            break;
          }
        } else {
          // No more earthquakes in the config file.
          break;
        }
      }
    }
    // Now set up the next earthquake.
    this->nextEarthquake();
  }
  if( old < 57 ) {
    this.user_actions_allowed = true;
  }
  if( old < 61 ) {
    // room remove callbacks added
    this.room_remove_callbacks = {};
  }
  if( old < 64 ) {
    // added reference to world for staff profiles
    for( _, group in pairs(this.available_staff) ) {
      for( _, profile in ipairs(group) ) {
        profile.world = this;
      }
    }
  }
  if( old < 66 ) {
    // Unreserve objects which are not actually reserved for real in the staff room.
    // This is a special case where reserved_for could be set just as a staff member was leaving
    for( _, room in pairs(this.rooms) ) {
      if( room.room_info.id == "staff_room" ) {
        // Find all objects in the room
        var fx, fy = room->getEntranceXY(true);
        for( obj, _ in pairs(this->findAllObjectsNear(fx, fy)) ) {
          if( obj.reserved_for ) {
            var found = false;
            for( _, action in ipairs(obj.reserved_for.action_queue) ) {
              if( action.name == "use_object" ) {
                if( action.object == obj ) {
                  found = true;
                  break;
                }
              }
            }
            if( ! found ) {
              this->gameLog("Unreserved an object: " .. obj.object_type.id .. " at " .. obj.tile_x .. ":" .. obj.tile_y);
              obj.reserved_for = null;
            }
          }
        }
      }
    }
  }
  if( old < 77 ) {
    this.ui->addKeyHandler({"shift", "+"}, this, this.adjustZoom,  5);
    this.ui->addKeyHandler({"shift", "-"}, this, this.adjustZoom, -5);
  }

  if( old < 103 ) {
    // If a room has patients who no longer exist in its
    // humanoids_enroute table because of #133 remove them:
    for( _, room in pairs(this.rooms) ) {
      for( patient, _ in pairs(room.humanoids_enroute) ) {
        if( patient.tile_x == null ) {
          room.humanoids_enroute[patient] = null;
        }
      }
    }
  }
  if( old < 124 ) {
    this.game_date = Date(this.year, this.month, this.day, this.hour);
    // self.next_vip_month is number of months since the game start
    this.next_vip_date = Date(1, this.next_vip_month, this.next_vip_day);
  }

  // Now let things inside the world react.
  for( _, cat in pairs({this.hospitals, this.entities, this.rooms}) ) {
    for( _, obj in pairs(cat) ) {
      obj->afterLoad(old, new);
    }
  }

  if( old < 80 ) {
    this->determineWinningConditions();
  }

  if( old >= 87 ) {
    this->playLoadedEntitySounds();
  }

  if( old < 88 ) {
    //Populate the entity map
    this.entity_map = EntityMap(this.map);
    for( _, e in ipairs(this.entities) ) {
      var x, y = e.tile_x, e.tile_y;
      if( x && y ) {
        this.entity_map->addEntity(x,y,e);
      }
    }
  }
  if( old < 108 ) {
    this.room_build_callbacks = null;
  }
  if( old < 113 ) { // Make cleanable littered tiles buildable.
    for( x = 1, this.map.width ) {
      for( y = 1, this.map.height ) {
        var litter = this->getObject(x, y, "litter");
        if( litter && litter->isCleanable() ) { this.map->setCellFlags(x, y, {buildable=true}); }
      }
    }
  }
  if( old < 115 ) {
    this.next_earthquake = {
      start_month = this.next_earthquake_month,
      start_day = this.next_earthquake_day,
      size = this.earthquake_size,
      active = this.earthquake_active || false
    };
    this.next_earthquake_month = null;
    this.next_earthquake_day = null;
    this.earthquake_stop_day = null;
    this.earthquake_size = null;
    this.earthquake_active = null;
    this.randomX = null;
    this.randomY = null;
    this.currentX = null;
    this.currentY = null;

    if( this.next_earthquake.active ) {
      var rd = 0;
      for( _, room in pairs(this.rooms) ) {
        for( object, _ in pairs(room.objects) ) {
          if( object.quake_points ) {
            rd = math.max(rd, object.quake_points);
            object.quake_points = null;
          }
        }
      }
      this.next_earthquake.remaining_damage = rd;
      this.next_earthquake.damage_timer = earthquake_damage_time;
      this.next_earthquake.warning_timer = 0;
    } else {
      this.next_earthquake.remaining_damage = this.next_earthquake.size;
      this.next_earthquake.damage_timer = earthquake_damage_time;
      this.next_earthquake.warning_timer = earthquake_warning_period;
    }
  }
  if( old < 120 ) {
    // Issue #1105 updates to fix any broken saves with travel<dir> flags for side objects
    this->resetSideObjects();
  }

  this.savegame_version = new;
}

function World::playLoadedEntitySounds() {
  for( _, entity in pairs(this.entities) ) {
    entity->playAfterLoadSound();
  }
}

/* There is a problem with room editing in that it resets all the partial passable flags
(travelNorth, travelSouth etc.) in the corridor, a workaround is calling this function
after the room was edited so that all edge only objects, that set partial passable flags set
those flags again*/
function World::resetSideObjects() {
  for( _, objects in pairs(this.objects) ) {
    for( _, obj in ipairs(objects) ) {
      if( obj.object_type.class == "SideObject" ) {
        obj->setTile(obj.tile_x, obj.tile_y);
      }
    }
  }
}

/* When placing doors and objects the passable tiles need to be checked for overlapping
passable tiles. This presents problems with objects like Bench where the passable tile
is not for exclusive use of the Bench (another object can share that same tile)
the footprint.shareable differentiates shareable passable tiles, and exclusive use
passable tiles (the norm for most objects)*/
//!param x (int) x map tile position
//!param y (int) y map tile position
//!param distance (int) searchable distance for nearby objects
//!return (boolean) indicating if exclusively passable or not
function World::isTileExclusivelyPassable(x, y, distance) {
  for( o in pairs(this->findAllObjectsNear(x, y, distance)) ) {
    if( o && o.footprint ) {
      for( _, footprint in pairs(o.footprint) ) {
        if( footprint[1] + o.tile_x == x && footprint[2] + o.tile_y == y && footprint.only_passable && ! footprint.shareable ) {
          return false;
        }
      }
    } else {
      // doors don't have a footprint but objects can't be built blocking them either
      for( _, footprint in pairs(o->getWalkableTiles()) ) {
        if( o.object_type && o.object_type.thob != 62 && footprint[1] == x && footprint[2] == y ) {
          return false;
        }
      }
    }
  }
  return true;
}

function World::date() {
  return this.game_date->clone();
}
