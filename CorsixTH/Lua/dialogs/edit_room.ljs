/* Copyright (c) 2009 Peter "Corsix" Cawley

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE. --*/

corsixth.require("dialogs.place_objects");

class ("UIEditRoom") (UIPlaceObjects);

//-@type UIEditRoom
var UIEditRoom = _G["UIEditRoom"];

function UIEditRoom::UIEditRoom(ui, room_type) {

  // NB: UIEditRoom:onCursorWorldPositionChange is called by the UIPlaceObjects
  // constructor, hence the initialisation of required fields prior to the call.
  this.UIPlaceObjects(this, ui);
  this->addKeyHandler("return", this.confirm); // UIPlaceObjects does not need this
  this->addKeyHandler("keypad enter", this.confirm);

  var app = ui.app;
  var blue_red_swap = this.anims.Alt32_BlueRedSwap;
  // Set alt palette on wall blueprint to make it red
  this.anims->setAnimationGhostPalette(124, app.gfx->loadGhost("QData", "Ghost1.dat", 6), blue_red_swap);
  // Set on door and window blueprints too
  this.anims->setAnimationGhostPalette(126, app.gfx->loadGhost("QData", "Ghost1.dat", 6), blue_red_swap);
  this.anims->setAnimationGhostPalette(130, app.gfx->loadGhost("QData", "Ghost1.dat", 6), blue_red_swap);
  this.cell_outline = TheApp.gfx->loadSpriteTable("Bitmap", "aux_ui", true);
  if( ! room_type.room_info ) {
    this.blueprint_rect = {
      x = 1,
      y = 1,
      w = 0,
      h = 0,
    };
    if( room_type.swing_doors ) {
      this.blueprint_door = {anim = {}, old_anim = {}, old_flags = {}};
    } else {
      this.blueprint_door = {};
    }
    this.phase = "walls"; //> "door" --> "windows" --> "clear_area" --> "objects" --> "closed"
    this.room_type = room_type;
    this.title_text = room_type.name;
    this.desc_text = _S.place_objects_window.drag_blueprint;
  } else {
    this.phase = "objects";
    this.room_type = room_type.room_info;
    this.title_text = room_type.room_info.name;
    this.room = room_type;
    this.desc_text = _S.place_objects_window.confirm_or_buy_objects;
    this.paid = true;
    this.blueprint_rect = {
      x = room_type.x,
      y = room_type.y,
      w = room_type.width,
      h = room_type.height,
    };
    if( room_type.room_info.swing_doors ) {
      this.blueprint_door = {anim = {}, old_anim = {}, old_flags = {}};
    } else {
      this.blueprint_door = {};
    }
    this.ui->setWorldHitTest(this.room);
    this.pickup_button->enable(true);
    this.purchase_button->enable(true);
    this->checkEnableConfirm();
  }
  this.blueprint_wall_anims = {
  };
  this.blueprint_window = {
  };
  this.mouse_down_x = false;
  this.mouse_down_y = false;
  this.mouse_cell_x = 0;
  this.mouse_cell_y = 0;
}

function UIEditRoom::close(...) {
  if( this.phase == "objects" && this.confirm_button.enabled ) {
    if( ! this.closed_cleanly ) {
      this->confirm(true);
    }
  } else {
    while( this.phase != "walls" ) {
      this->cancel();
    }
  }
  for( k, obj in pairs(this.blueprint_wall_anims) ) {
    if( obj.setTile ) {
      obj->setTile(null);
    } else {
      for( _, anim in pairs(obj) ) {
        anim->setTile(null);
      }
    }
    this.blueprint_wall_anims[k] = null;
  }
  this.phase = "closed";
  // No longer editing a room
  this.ui.edit_room = false;
  this->setBlueprintRect(1, 1, 0, 0);
  this.ui->tutorialStep(3, {4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}, 1); // not all of these links may be needed, but to be safe...
  return UIPlaceObjects.close(this, ...);
}

/* Called when building/editing of the room is about to stop because another
     dialog is being opened. If the room is in the objects phase and all
     required objects have been placed it will be completed. Otherwise
     it is cancelled instead.
--*/
function UIEditRoom::verifyOrAbortRoom() {
  if( this.phase == "objects" && this.confirm_button.enabled ) {
    // The room can be finished
    this->close();
  } else {
    // The room will have to be cancelled
    this->abortRoom();
  }
}

function UIEditRoom::abortRoom() {
  if( this.paid ) {
    // Return half the cost.
    var progress = this.ui.hospital.research.research_progress;
    var cost = math.floor(progress[this.room.room_info].build_cost/2);
    // TODO: Return also the cost for additional objects.

    // Decrease the hospital value by the whole room build cost
    var valueChange = progress[this.room.room_info].build_cost;
    for( obj, num in pairs(this.room.room_info.objects_needed) ) {
      // Get how much this item costs.
      var obj_cost = this.ui.hospital->getObjectBuildCost(obj);
      cost = cost - math.floor(obj_cost)/2;
      valueChange = valueChange - num * obj_cost;
    }
    this.ui.hospital->receiveMoney(cost, _S.transactions.sell_object, valueChange);
  }
  // Close the dialog
  this->close();
  // Finally remove the room from the world (close() needs the reference)
  if( this.room ) {
    this.room->deactivate(); // TODO: may be superfluous since already called in Room:tryToEdit
    this.world.rooms[this.room.id] = null;
  }
}

function UIEditRoom::cancel() {
  if( this.confirm_dialog_open ) {
    // Don't do anything as long as the confirm dialog is open.
    return;
  }
  if( this.phase == "walls" ) {
    if( this.paid ) {
      // While the confirmation window is open, don't allow the player to click the confirm button.
      this.confirm_button->enable(false);
      this.confirm_dialog_open = true;
      // Ask if the user really wish to sell this room
      this.ui->addWindow(UIConfirmDialog(this.ui,
        _S.confirmation.delete_room,
        /*persistable:delete_room_confirm_dialog*/function() {
          this->abortRoom();
        },
        /*persistable:delete_room_confirm_dialog_cancel*/function() {
          this.confirm_button->enable(true);
          this.confirm_dialog_open = null;
        }
      ));
    } else {
      this->close();
    }
    this.ui->setCursor(this.ui.default_cursor);
  } else if( this.phase == "objects" ) {
    this->stopPickupItems();
    this->returnToDoorPhase();
    this.world->resetSideObjects();
  } else {
    if( this.phase == "clear_area" ) {
      this.ui->setDefaultCursor(null);
      this.check_for_clear_area_timer = null;
      this.humanoids_to_watch = null;
    }
    this.phase = "walls";
    this->returnToWallPhase();
  }
}

function UIEditRoom::confirm(force) {
  // double check if confirm is allowed (for being called e.g. by hotkey)
  if( ! force && ! this.confirm_button.enabled ) {
    return;
  }
  this->stopPickupItems();

  if( this.phase == "walls" ) {
    this.mouse_down_x = false;
    this.mouse_down_y = false;
    this.move_rect_x = false;
    this.move_rect_y = false;
    this.phase = "door";
    this->enterDoorPhase();
  } else if( this.phase == "door" ) {
    this.phase = "windows";
    this->enterWindowsPhase();
  } else if( this.phase == "windows" ) {
    this.phase = "clear_area";
    this->clearArea();
  } else if( this.phase == "clear_area" ) {
    this.ui->setDefaultCursor(null);
    this.phase = "objects";
    this->finishRoom();
    this.world->resetSideObjects();
    this->enterObjectsPhase();
  } else {
    // Pay for room (subtract cost of needed objects, which were already paid for)
    if( ! this.paid ) {
      var progress = this.ui.hospital.research.research_progress;
      var cost = progress[this.room.room_info].build_cost;
      for( obj, num in pairs(this.room.room_info.objects_needed) ) {
        // Get how much this item costs.
        var obj_cost = this.ui.hospital->getObjectBuildCost(obj);
        cost = cost - num * obj_cost;
      }
      this.ui.hospital->spendMoney(cost, _S.transactions.build_room .. ": " .. this.title_text, cost);
      this.paid = true;
    }

    this.world->markRoomAsBuilt(this.room);
    this.closed_cleanly = true;
    // If information dialogs are disabled, go ahead.
    if( this.ui->getWindow(UIInformation) ) {
      this.ui->tutorialStep(3, 15, 16);
    } else {
      this.ui->tutorialStep(3, 15, "next");
    }
    this->close();
  }
}

var function isHumanoidObscuringArea(humanoid, x1, x2, y1, y2) {
  if( humanoid.tile_x ) {
    if( x1 <= humanoid.tile_x && humanoid.tile_x <= x2 &&
        y1 <= humanoid.tile_y && humanoid.tile_y <= y2 ) {
      if( (x1 == humanoid.tile_x || x2 == humanoid.tile_x) ||
          (y1 == humanoid.tile_y || y2 == humanoid.tile_y) ) {
        // Humanoid not in the rectangle, but might be walking into it
        var action = humanoid->getCurrentAction();
        if( action.name != "walk" ) {
          return false;
        }
        if( action.path_x ) { // in a (rare) special case, path_x is nil (see action_walk_start)
          var next_x = action.path_x[action.path_index];
          var next_y = action.path_y[action.path_index];
          if( x1 >= next_x || next_x >= x2 || y1 >= next_y || next_y >= y2 ) {
            return false;
          }
        }
      }
      return true;
    }
  }
  return false;
}

function UIEditRoom::clearArea() {
  this.confirm_button->enable(false);
  var rect = this.blueprint_rect;
  var world = this.ui.app.world;
  world->clearCaches(); // To invalidate idle tiles in case we need to move people
  var humanoids_to_watch = setmetatable({}, {__mode = "k"});
  {
    var x1 = rect.x - 1;
    var x2 = rect.x + rect.w;
    var y1 = rect.y - 1;
    var y2 = rect.y + rect.h;
    for( _, entity in ipairs(world.entities) ) {
      if( class.is(entity, Humanoid) &&
          isHumanoidObscuringArea(entity, x1, x2, y1, y2) ) {
        humanoids_to_watch[entity] = true;

        // Try to make the humanoid leave the area
        var current_action = entity->getCurrentAction();
        var meander = entity.action_queue[2];
        if( meander && meander.name == "meander" ) {
          // Interrupt the idle or walk, which will cause a new meander target
          // to be chosen, which will be outside the blueprint rectangle
          meander.can_idle = false;
          var on_interrupt = current_action.on_interrupt;
          if( on_interrupt ) {
            current_action.on_interrupt = null;
            on_interrupt(current_action, entity);
          }
        } else if( current_action.name == "seek_room" || (meander && meander.name == "seek_room") ) {
          // Make sure that the humanoid doesn't stand idle waiting within the blueprint
          if( current_action.name == "seek_room" ) {
            entity->queueAction(MeanderAction()->setCount(1)->setMustHappen(true), 0);
          } else {
            meander.done_walk = false;
          }
        } else {
          // Look for a queue action and re-arrange the people in it, which
          // should cause anyone queueing within the blueprint to move
          for( _, action in ipairs(entity.action_queue) ) {
            if( action.name == "queue" ) {
              for( _, humanoid in ipairs(action.queue) ) {
                var callbacks = action.queue.callbacks[humanoid];
                if( callbacks ) {
                  callbacks->onChangeQueuePosition(humanoid);
                }
              }
              break;
            }
          }
          // TODO: Consider any other actions which might be causing the
          // humanoid to be staying within the rectangle for a long time.
        }
      }
    }
  }

  if( next(humanoids_to_watch) == null ) {
    // No humanoids within the area, so continue with the room placement
    this->confirm(true);
    return;
  }

  this.check_for_clear_area_timer = 10;
  this.humanoids_to_watch = humanoids_to_watch;
  this.ui->setCursor(this.ui.waiting_cursor);
}

function UIEditRoom::onTick() {
  UIFurnishCorridor.onTick(this);
  if( this.check_for_clear_area_timer ) {
    this.check_for_clear_area_timer = this.check_for_clear_area_timer - 1;
    if( this.check_for_clear_area_timer == 0 ) {
      var rect = this.blueprint_rect;
      var x1 = rect.x - 1;
      var x2 = rect.x + rect.w;
      var y1 = rect.y - 1;
      var y2 = rect.y + rect.h;
      for( humanoid in pairs(this.humanoids_to_watch) ) {
        // The person might be dying (this check should probably be moved into
        // isHumanoidObscuringArea, but I don't want to change too much right
        // before a release).
        if( humanoid->getCurrentAction().name == "die" ) {
          if( ! humanoid.hospital ) {
            this.humanoids_to_watch[humanoid] = null;
          }
        } else if( ! isHumanoidObscuringArea(humanoid, x1, x2, y1, y2) ) {
          this.humanoids_to_watch[humanoid] = null;
        }
      }
      if( next(this.humanoids_to_watch) ) {
        this.check_for_clear_area_timer = 10;
      } else {
        this.check_for_clear_area_timer = null;
        this.humanoids_to_watch = null;
        this->confirm(true);
      }
    }
  }
}

function UIEditRoom::finishRoom() {
  var room_type = this.room_type;
  var wall_type = this.ui.app.walls[room_type.wall_type];
  var world = this.ui.app.world;
  var map = this.ui.app.map.th;
  var rect = this.blueprint_rect;
  var door, door2;
  // Add the transparency flag if it is set.
  var flag = 0;
  if( this.ui.transparent_walls ) {
    flag = 1024;
  }
  var function check_external_window(x, y, layer) {
    // If a wall is built which is normal to an external window, then said
    // window needs to be removed, otherwise it looks odd (see issue #59).
    var block = map->getCell(x, y, layer);
    var dir = world->getWallDirFromBlockId(block);
    var tiles = this.ui.app.walls.external[world->getWallSetFromBlockId(block)];
    if( dir == "north_window_1" ) {
      if( x != rect.x ) {
        map->setCell(x, y, layer, flag + tiles.north);
        if( map->getCell(x + 1, y, layer) != 0 ) {
          map->setCell(x + 1, y, layer, flag + tiles.north);
        }
      }
    } else if( dir == "north_window_2" ) {
      if( x == rect.x ) {
        if( map->getCell(x - 1, y, layer) != 0 ) {
          map->setCell(x - 1, y, layer, flag + tiles.north);
        }
        map->setCell(x, y, layer, flag + tiles.north);
      }
    } else if( dir == "west_window_1" ) {
      if( y == rect.y ) {
        map->setCell(x, y, layer, flag + tiles.west);
        if( map->getCell(x, y - 1, layer) != 0 ) {
          map->setCell(x, y - 1, layer, flag + tiles.west);
        }
      }
    } else if( dir == "west_window_2" ) {
      if( y != rect.y ) {
        if( map->getCell(x, y + 1, layer) != 0 ) {
          map->setCell(x, y + 1, layer, flag + tiles.west);
        }
        map->setCell(x, y, layer, flag + tiles.west);
      }
    }
  }
  for( x, obj in pairs(this.blueprint_wall_anims) ) {
    for( y, anim in pairs(obj) ) {
      if( x == rect.x && y == rect.y ) {
        var _, east, north = map->getCell(x, y);
        if( world->getWallIdFromBlockId(east) == "external" ) {
          check_external_window(x, y, 2);
        } else if( world->getWallSetFromBlockId(east) == "window_tiles" ) {
          map->setCell(x, y, 2, flag + wall_type.window_tiles.north);
        } else {
          map->setCell(x, y, 2, flag + wall_type.inside_tiles.north);
        }
        if( world->getWallIdFromBlockId(north) == "external" ) {
          check_external_window(x, y, 3);
        } else if( world->getWallSetFromBlockId(north) == "window_tiles" ) {
          map->setCell(x, y, 3, flag + wall_type.window_tiles.west);
        } else {
          map->setCell(x, y, 3, flag + wall_type.inside_tiles.west);
        }
      } else {
        do {
          var tiles = "outside_tiles";
          var tag = anim->getTag();
          if( tag == "nothing" || tag == "swing_slave" ) {
            tiles = "swing_outside_tiles";
          }
          var dir = (anim->getFlag() % 2 == 1) && "west" || "north";
          var layer = dir == "north" && 2 || 3;
          if( world->getWallIdFromBlockId(map->getCell(x, y, layer)) == "external" ) {
            if( layer == 2 ) {
              if( (x == rect.x || x == rect.x + rect.w - 1) && (y == rect.y || y == rect.y + rect.h) ) {
                check_external_window(x, y, 2);
              }
            } else {
              if( (x == rect.x || x == rect.x + rect.w) && (y == rect.y || y == rect.y + rect.h - 1) ) {
                check_external_window(x, y, 3);
              }
            }
            break;
          }
          var existing = world->getWallSetFromBlockId(map->getCell(x, y, layer));
          if( rect.x <= x && x < rect.x + rect.w && rect.y <= y && y < rect.y + rect.h ) {
            if( tag == "nothing" || tag == "swing_slave" ) {
              tiles = "swing_inside_tiles";
            } else {
              tiles = "inside_tiles";
            }
          } else if( existing ) {
            break;
          }
          if( tag == "window" || existing == "window_tiles" ) {
            tiles = "window_tiles";
          }
          var suffixes = {"_left", "_right"};
          var num = dir == "north" && 1 || 0;
          if( tag == "door" ) {
            door = world->newObject("door", x, y, dir);
          } else if( tag == "swing_master" ) {
            door = world->newObject("swing_door_right", x, y, dir);
          } else if( tag == "swing_slave" ) {
            door2 = world->newObject("swing_door_left", x, y, dir);
            map->setCell(x, y, layer, flag + wall_type[tiles][dir .. suffixes[2 - num]]);
          } else if( tag == "nothing" ) {
            map->setCell(x, y, layer, flag + wall_type[tiles][dir .. suffixes[num + 1]]);
          } else {
            map->setCell(x, y, layer, flag + wall_type[tiles][dir]);
          }
        } while(!( true) );
      }
      anim->setTile(null);
    }
    this.blueprint_wall_anims[x] = null;
  }
  // If there is already a room, e.g. it is being moved, don't make a new one.
  if( this.room ) {
    this.room->initRoom(rect.x, rect.y, rect.w, rect.h, door, door2);
  } else {
    this.room = this.world->newRoom(rect.x, rect.y, rect.w, rect.h, room_type, door, door2);
  }
}

function UIEditRoom::purchaseItems() {
  this.visible = false;
  this.place_objects = false;
  this->stopPickupItems();

  var cfg_objects = this.world.map.level_config.objects;
  var research = this.ui.hospital.research;

  var object_list = {}; // transform set to list
  for( i, o in ipairs(this.room.room_info.objects_additional) ) {
    // Don't show the object if it hasn't been researched yet.
    var object = TheApp.objects[o];
    var avail = cfg_objects[object.thob].AvailableForLevel;
    if( avail == 1 && (! research.research_progress[object] ||
        research.research_progress[object].discovered) ) {
      // look up current quantity
      var cur_qty = 0;
      for( _, p in ipairs(this.objects) ) {
        if( p.object.id == o ) {
          cur_qty = p.qty;
        }
      }

      // look up minimum quantity (required objects list)
      var min_qty = this.room.room_info.objects_needed[o] || 0;

      // subtract number of objects in room from minimum quantity
      for( obj, _ in pairs(this.room.objects) ) {
        if( min_qty == 0 ) { break; }
        if( obj.object_type.id == o ) {
          --min_qty    ;
        }
      }
      object_list[i] = { object = TheApp.objects[o], qty = cur_qty, min_qty = min_qty };
    }
  }

  this.ui->addWindow(UIFurnishCorridor(this.ui, object_list, this));
}

// callback for item pick up button
function UIEditRoom::pickupItems() {
  if( this.in_pickup_mode ) {
    this->stopPickupItems();
  } else {
    this.in_pickup_mode = true;
    this.ui->setCursor(this.ui.grab_cursor);
    this.place_objects = false;
    this.active_index = 0;
    this.object_cell_x = null;
    this.object_cell_y = null;
    this->clearBlueprint();
  }
}

function UIEditRoom::stopPickupItems() {
  if( this.in_pickup_mode ) {
    this.in_pickup_mode = false;
    this.ui->setCursor(this.ui.default_cursor);
    this.pickup_button->setToggleState(false);
  }
}

function UIEditRoom::returnToWallPhase(early) {
  this.ui->tutorialStep(3, {9, 10, 11, 12}, 4);
  if( ! early ) {
    this.desc_text = _S.place_objects_window.drag_blueprint;
    this.confirm_button->enable(true);
    for( k, obj in pairs(this.blueprint_wall_anims) ) {
      for( _, anim in pairs(obj) ) {
        anim->setTile(null);
      }
      this.blueprint_wall_anims[k] = null;
    }
  }
  var rect = this.blueprint_rect;
  var x, y, w, h = rect.x, rect.y, rect.w, rect.h;
  this->setBlueprintRect(1, 1, 0, 0);
  this->setBlueprintRect(x, y, w, h);
  if( this.room_type.swing_doors ) {
    this.blueprint_door = {anim = {}, old_anim = {}, old_flags = {}};
  } else {
    this.blueprint_door = {};
  }
}

function UIEditRoom::returnToDoorPhase() {
  this.ui->tutorialStep(3, {13, 14, 15}, 9);
  var map = this.ui.app.map.th;
  var room = this.room;
  room.built = false;
  if( room.door && room.door.queue ) {
    room.door.queue->rerouteAllPatients(SeekRoomAction(room.room_info.id));
  }

  this.purchase_button->enable(false);
  this.pickup_button->enable(false);

  // Remove any placed objects (add them to list again)
  for( x = room.x, room.x + room.width - 1 ) {
    for( y = room.y, room.y + room.height - 1 ) {
      while( true ) {
        var obj = this.world->getObject(x, y);
        if( ! obj || obj == room.door || class.is(obj, SwingDoor) ) {
          break;
        }
        if( obj.object_type.id == "litter" ) { // Silently remove litter from the world.
          obj.remove();
          break;
        }
        var obj_state = obj->getState();
        this.world->destroyEntity(obj);
        if( ! obj.master ) {
          this->addObjects({{
            object = TheApp.objects[obj.object_type.id],
            state = obj_state,
            qty = 1
          }});
        }
      }
    }
  }
  this.world->destroyEntity(this.room.door);
  if( this.room.door2 ) {
    this.world->destroyEntity(this.room.door2);
  }

  // backup list of objects
  this.objects_backup = {};
  for( k, o in pairs(this.objects) ) {
    this.objects_backup[k] = { object = o.object, qty = o.qty, state = o.state };
  }

  UIPlaceObjects.removeAllObjects(this, true);

  // Remove walls
  var function remove_wall_line(x, y, step_x, step_y, n_steps, layer, neigh_x, neigh_y) {
    for( _ = 1, n_steps ) {
      var existing = map->getCell(x, y, layer);
      // Possibly add transparency.
      var flag = 0;
      if( this.ui.transparent_walls ) {
        flag = 1024;
      }
      if( this.world->getWallIdFromBlockId(existing) != "external" ) {
        var neighbour = this.world->getRoom(x + neigh_x, y + neigh_y);
        if( neighbour ) {
          if( neigh_x != 0 || neigh_y != 0 ) {
            var set = this.world->getWallSetFromBlockId(existing);
            var dir = this.world->getWallDirFromBlockId(existing);
            if( set == "inside_tiles" ) {
              set = "outside_tiles";
            }
            map->setCell(x, y, layer, flag + this.world.wall_types[neighbour.room_info.wall_type][set][dir]);
          }
        } else {
          map->setCell(x, y, layer, flag);
        }
      }
      x +=   step_x;
      y +=   step_y;
    }
  }
  remove_wall_line(room.x, room.y, 0, 1, room.height, 3, -1,  0);
  remove_wall_line(room.x, room.y, 1, 0, room.width , 2,  0, -1);
  remove_wall_line(room.x + room.width, room.y , 0, 1, room.height, 3, 0, 0);
  remove_wall_line(room.x, room.y + room.height, 1, 0, room.width , 2, 0, 0);

  // Reset floor tiles and flags
  this.world.map.th->unmarkRoom(room.x, room.y, room.width, room.height);

  // Re-create blueprint
  var rect = this.blueprint_rect;
  var old_w, old_h = rect.w, rect.h;
  rect.w = 0;
  rect.h = 0;
  this->setBlueprintRect(rect.x, rect.y, old_w, old_h);

  // We've gone all the way back to wall phase, so step forward to door phase
  this.phase = "door";
  this->enterDoorPhase();
}

function UIEditRoom::screenToWall(x, y) {
  var cellx, celly = this.ui->ScreenToWorld(x, y);
  cellx = math.floor(cellx);
  celly = math.floor(celly);
  var rect = this.blueprint_rect;

  if( cellx == rect.x || cellx == rect.x - 1 || cellx == rect.x + rect.w || cellx == rect.x + rect.w - 1 ||
     celly == rect.y || celly == rect.y - 1 || celly == rect.y + rect.h || celly == rect.y + rect.h - 1 ) {
  } else {
    return;
  }

  // NB: Doors and windows cannot be placed on corner tiles, hence walls of corner tiles
  // are never returned, and the nearest non-corner wall is returned instead. If they
  // could be placed on corner tiles, then you would have to consider the interaction of
  // wall shadows with windows and doors, amonst other things.
  // Swing doors are allowed to be adjacent everywhere except the top corner.
  var modifier = 0;
  var swinging = false;
  if( this.room_type.swing_doors && this.phase == "door" ) {
    modifier = 1;
    swinging = true;
  }
  if( cellx == rect.x && celly == rect.y ) {
    // top corner
    var x_, _ = this.ui->WorldToScreen(cellx, celly);
    if( x >= x_ ) {
      // correctly reflects (at least origin version) of TH.
      // Swing doors in top corner to the east, actually skip another tile
      if( swinging ) {
        return cellx + 2 + modifier, celly, "north";
      } else {
        return cellx + 1 + modifier, celly, "north";
      }
    } else {
      return cellx, celly + 1 + modifier, "west";
    }
  } else if( cellx == rect.x + rect.w - 1 && celly == rect.y + rect.h - 1 ) {
    // bottom corner
    var x_, _ = this.ui->WorldToScreen(cellx, celly);
    if( x >= x_ ) {
      return cellx, celly - 1, "east";
    } else {
      return cellx - 1, celly, "south";
    }
  } else if( cellx == rect.x && celly == rect.y + rect.h - 1 ) {
    // left corner
    var _, y_ = this.ui->WorldToScreen(cellx, celly);
    if( y >= y_ + 16 ) {
      if( swinging && cellx <= rect.x + 2 ) {
        return cellx + 1 + modifier, celly, "south";
      } else {
        return cellx + 1, celly, "south";
      }
    } else {
      return cellx, celly - 1, "west";
    }
  } else if( cellx == rect.x + rect.w - 1 && celly == rect.y ) {
    // right corner
    var _, y_ = this.ui->WorldToScreen(cellx, celly);
    if( y >= y_ + 16 ) {
      if( swinging && celly <= rect.y + 2 ) {
        return cellx, celly + 1 + modifier, "east";
      } else {
        return cellx, celly + 1, "east";
      }
    } else {
      return cellx - 1, celly, "north";
    }
  } else if( (cellx == rect.x - 1 || cellx == rect.x) && rect.y <= celly && celly < rect.y + rect.h ) {
    // west edge
    if( celly == rect.y ) {
      celly = rect.y + 1;
    } else if( celly == rect.y + rect.h - 1 ) {
      celly = rect.y + rect.h - 2;
    }
    if( swinging && celly <= rect.y + 1 ) {
      ++celly    ;
    }
    return rect.x, celly, "west";
  } else if( (celly == rect.y - 1 || celly == rect.y) && rect.x <= cellx && cellx < rect.x + rect.w ) {
    // north edge
    // correctly reflects (at least origin version) of TH.
    // Swing doors in top corner to the east, actually skip another tile
    if( swinging && cellx <= rect.x + 2 ) {
      cellx = rect.x + 3;
    } else if( cellx == rect.x ) {
      cellx = rect.x + 1 + modifier;
    } else if( cellx == rect.x + rect.w - 1 ) {
      cellx = rect.x + rect.w - 2;
    }
    return cellx, rect.y, "north";
  } else if( (cellx == rect.x + rect.w || cellx == rect.x + rect.w - 1) &&
      rect.y <= celly && celly < rect.y + rect.h ) {
      // east edge
    if( swinging && celly <= rect.y + 1 ) {
      celly = rect.y + 2;
    } else if( celly == rect.y ) {
      celly = rect.y + 1;
    } else if( celly == rect.y + rect.h - 1 ) {
      celly = rect.y + rect.h - 2;
    }
    return rect.x + rect.w - 1, celly, "east";
  } else if( (celly == rect.y + rect.h || celly == rect.y + rect.h - 1) &&
      rect.x <= cellx && cellx < rect.x + rect.w ) {
    // south edge
    if( swinging && cellx <= rect.x + 1 ) {
      cellx = rect.x + 2;
    } else if( cellx == rect.x ) {
      cellx = rect.x + 1;
    } else if( cellx == rect.x + rect.w - 1 ) {
      cellx = rect.x + rect.w - 2;
    }
    return cellx, rect.y + rect.h - 1, "south";
  }
}

// Function to check if the tiles adjacent to the room are still reachable from each other.
// NB: the passable flags of the room have to be set to false already before calling this function
function UIEditRoom::checkReachability() {
  var map = this.ui.app.map.th;
  var world = this.ui.app.world;

  var rect = this.blueprint_rect;
  var prev_x, prev_y;
  var x, y = rect.x, rect.y - 1;
  var flags = {};

  var function check(flag) {
    if( map->getCellFlags(x, y, flags).passable && flags[flag] ) {
      if( prev_x && ! world->getPathDistance(prev_x, prev_y, x, y) ) {
        return false;
      }
      prev_x, prev_y = x, y;
    }
    return true;
  }

  while( x < rect.x + rect.w ) {
    if( ! check("travelSouth") ) { return false; }
    ++x    ;
  }
  ++y    ;
  while( y < rect.y + rect.h ) {
    if( ! check("travelWest") ) { return false; }
    ++y    ;
  }
  --x    ;
  while( x >= rect.x ) {
    if( ! check("travelNorth") ) { return false; }
    --x    ;
  }
  --y    ;
  while( y >= rect.y ) {
    if( ! check("travelEast") ) { return false; }
    --y    ;
  }

  return true;
}

function UIEditRoom::enterDoorPhase() {
  this.ui->tutorialStep(3, 8, 9);
  // make tiles impassable
  for( y = this.blueprint_rect.y, this.blueprint_rect.y + this.blueprint_rect.h - 1 ) {
    for( x = this.blueprint_rect.x, this.blueprint_rect.x + this.blueprint_rect.w - 1 ) {
      this.ui.app.map->setCellFlags(x, y, {passable = false});
    }
  }

  // check if all adjacent tiles of the rooms are still connected
  if( ! this->checkReachability() ) {
    // undo passable flags and go back to walls phase
    this.phase = "walls";
    this->returnToWallPhase(true);
    this.ui->playSound("wrong2.wav");
    this.ui.adviser->say(_A.room_forbidden_non_reachable_parts);
    return;
  }

  this.desc_text = _S.place_objects_window.place_door;
  this.confirm_button->enable(false); // Confirmation is via placing door

  // Change the floor tiles to opaque blue
  var map = this.ui.app.map.th;
  for( y = this.blueprint_rect.y, this.blueprint_rect.y + this.blueprint_rect.h - 1 ) {
    for( x = this.blueprint_rect.x, this.blueprint_rect.x + this.blueprint_rect.w - 1 ) {
      map->setCell(x, y, 4, 24);
    }
  }

  // Re-organise wall anims to index by x and y
  var walls = {};
  for( _, wall in ipairs(this.blueprint_wall_anims) ) {
    var _, x, y = wall->getTile();
    if( ! walls[x] ) {
      walls[x] = {};
    }
    walls[x][y] = wall;
  }
  this.blueprint_wall_anims = walls;
}

function UIEditRoom::enterWindowsPhase() {
  this.ui->tutorialStep(3, {9, 10}, 11);
  this.desc_text = _S.place_objects_window.place_windows;
  this.confirm_button->enable(true);
}

function UIEditRoom::enterObjectsPhase() {
  this.ui->setCursor(this.ui.default_cursor);
  this.ui->tutorialStep(3, {11, 12}, 13);
  this.ui->setWorldHitTest(this.room);
  var confirm = this->checkEnableConfirm();
  if( #this.room.room_info.objects_additional == 0 && confirm ) {
    this->confirm(true);
    return;
  }
  this.desc_text = _S.place_objects_window.confirm_or_buy_objects;
  if( #this.room.room_info.objects_additional > 0 ) {
    this.purchase_button->enable(true);
  }
  this.pickup_button->enable(true);

  if( this.objects_backup ) {
    this->addObjects(this.objects_backup, true);
  } else {
    var room_objects = this.room.room_info.objects_needed;
    if( TheApp.config.enable_avg_contents ) {
      room_objects = this->computeAverageContents();
    }
    var object_list = {}; // transform set to list
    for( o, num in pairs(room_objects) ) {
      if( num > 0 ) {
        object_list[#object_list + 1] = { object = TheApp.objects[o], qty = num };
      }
    }
    this->addObjects(object_list, true);
  }
}

// Decide contents of the new room based on average content of previous built rooms
// of the same type.
function UIEditRoom::computeAverageContents() {
  var average_objects = {}; // what does the average room of this type contain?
  var room_count = 0;
  for( _, room in pairs(this.world.rooms) ) {
    if( room && room.built && ! room.crashed &&
        room.hospital == this.ui.hospital && room.room_info == this.room_type ) {
      ++room_count    ;
      for( obj, _ in pairs(room.objects) ) {
        average_objects[obj.object_type.id] = (average_objects[obj.object_type.id] || 0) + 1;
      }
    }
  }
  // Ensure room contents is within the boundaries of objects_needed and objects_additional.
  var objects_needed = this.room.room_info.objects_needed;
  var additional_objects = {}; // Reversed mapping
  for( _, obj in pairs(this.room.room_info.objects_additional) ) {
    additional_objects[obj] = 1;
  }
  for( id, count in pairs(average_objects) ) {
    count = math.floor(count / room_count + 0.5);
    if( additional_objects[id] == null && objects_needed[id] == null ) {
      count = 0;
    }
    average_objects[id] = count;
  }
  for( id, count in pairs(objects_needed) ) {
    if( (average_objects[id] || 0) < count ) {
      average_objects[id] = count;
    }
  }
  return average_objects;
}

function UIEditRoom::draw(canvas, ...) {
  if( this.world.user_actions_allowed ) {
    var ui = this.ui;
    var x, y = ui->WorldToScreen(this.mouse_cell_x, this.mouse_cell_y);
    var zoom = this.ui.zoom_factor;
    if( canvas->scale(zoom) ) {
      x = math.floor(x / zoom);
      y = math.floor(y / zoom);
    }
    this.cell_outline->draw(canvas, 2, x - 32, y);
    canvas->scale(1);
  }

  UIPlaceObjects.draw(this, canvas, ...);
}

function UIEditRoom::onMouseDown(button, x, y) {
  if( this.world.user_actions_allowed && ! this.confirm_dialog_open ) {
    if( button == "left" ) {
      if( this.phase == "walls" ) {
        if( 0 <= x && x < this.width && 0 <= y && y < this.height ) {
        } else {
          var mouse_x, mouse_y = this.ui->ScreenToWorld(this.x + x, this.y + y);
          this.mouse_down_x = math.floor(mouse_x);
          this.mouse_down_y = math.floor(mouse_y);
          if( this.move_rect ) {
            this.move_rect_x = this.mouse_down_x - this.blueprint_rect.x;
            this.move_rect_y = this.mouse_down_y - this.blueprint_rect.y;
          } else if( this.resize_rect ) {
            // nothing to do
          } else {
            this->setBlueprintRect(this.mouse_down_x, this.mouse_down_y, 1, 1);
          }
        }
      } else if( this.phase == "door" ) {
        if( this.blueprint_door.valid ) {
          this.ui->playSound("buildclk.wav");
          this->confirm(true);
        } else {
          this.ui->tutorialStep(3, 9, 10);
        }
      } else if( this.phase == "windows" ) {
        this->placeWindowBlueprint();
      }
    }
  }
  return UIPlaceObjects.onMouseDown(this, button, x, y) || true;
}

function UIEditRoom::onMouseUp(button, x, y) {
  if( this.mouse_down_x ) {
    this.mouse_down_x = false;
    this.mouse_down_y = false;
  }

  if( this.move_rect_x ) {
    this.move_rect_x = false;
    this.move_rect_y = false;
  }

  return UIPlaceObjects.onMouseUp(this, button, x, y);
}

function UIEditRoom::onMouseMove(x, y, ...) {
  if( this.in_pickup_mode ) {
    this.ui->setCursor(this.ui.app.gfx->loadMainCursor("grab"));
  }
}

function UIEditRoom::setBlueprintRect(x, y, w, h) {
  var rect = this.blueprint_rect;
  var map = this.ui.app.map;
  if( x < 1 ) { x = 1; }
  if( y < 1 ) { y = 1; }
  if( x + w > map.width  ) { w = map.width  - x; }
  if( y + h > map.height ) { h = map.height - y; }

  if( rect.x == x && rect.y == y && rect.w == w && rect.h == h ) {
    // Nothing to do
    return;
  }

  var too_small = w < this.room_type.minimum_size || h < this.room_type.minimum_size;
  var player_id = this.ui.hospital->getPlayerIndex();

  // Entire update of floor tiles and wall animations done in C to replace
  // several hundred calls into C with just a single call. The price for this
  // is reduced flexibility. See l_map_updateblueprint in th_lua.cpp for code.
  var is_valid = map.th->updateRoomBlueprint(rect.x, rect.y, rect.w, rect.h,
    x, y, w, h, player_id, this.blueprint_wall_anims, this.anims, too_small);

  // NB: due to the unflexibility, tutorial step "too small AND invalid position" (3.7)
  //     is currently unusable, as it's not possible to determine if the position would
  //     have been invalid even if it weren't too small.
  if( this.phase != "closed" ) {
    if( too_small ) {
      this.ui->tutorialStep(3, {4, 5, 8}, 6);
    } else if( ! is_valid ) {
      this.ui->tutorialStep(3, {4, 6, 8}, 5);
    } else {
      this.ui->tutorialStep(3, {4, 5, 6}, 8);
    }
  }

  this.confirm_button->enable(is_valid);

  rect.x = x;
  rect.y = y;
  rect.w = w;
  rect.h = h;
}

//25 north wall, west
//26 north wall, east
//27 east wall, south
//28 east wall, north
//29 south wall, west
//30 south wall, east
//31 west wall, south
//32 west wall, north
// single door blue print values matching TH
var door_floor_blueprint_markers = {
  north = 26,
  east = 27,
  south = 30,
  west = 31
};

var window_floor_blueprint_markers = {
  north = 33,
  east = 34,
  south = 35,
  west = 36,
};

//! Check walls for having room for the door
//!param x (int) X tile position of the door.
//!param y (int) Y tile position of the door.
//!param wall (string) Name of the wall (either 'north' or 'west').
//!param has_swingdoor (boolean) Whether the room has a normal door (false) or a swing door (true) as entrance.
//!return (int) bit flags indicating invalid tile position using 1 based power of 2 as this works with ipairs
//!  values returned are the enumeration of
//!  4 = centre door in swing door or for single door the value can just be non-zero but uses the same bit of code
//!  2 (door section closer to top of screen) - smaller x or y
//!  8 (door section closer to bottom of screen) - larger x or y
var function checkDoorWalls(x, y, wall, has_swingdoor) {
  var th = TheApp.map.th;

  var dx, dy, wall_num;
  if( wall == "west" ) {
    wall_num = 3;
    dx = 0;
    dy = 1;
  } else {
    wall_num = 2;
    dx = 1;
    dy = 0;
  }
  var invalid_tile = 0;
  if( th->getCell(x, y, wall_num) % 0x100 != 0 ) {
    invalid_tile = 4;
  }

  // If it is a swing door there are two more locations to check.
  if( has_swingdoor ) {
    if( th->getCell(x - dx, y - dy, wall_num) % 0x100 != 0 ) {
      invalid_tile +=   2;
    }
    if( th->getCell(x + dx, y + dy, wall_num) % 0x100 != 0 ) {
      invalid_tile +=   8;
    }
  }
  return invalid_tile;
}

//! Check whether the given tile can function as a door entry/exit tile.
//!param xpos (int) X position of the tile.
//!param ypos (int) Y position of the tile.
//!param player_id (int) Player id owning the hospital.
//!param world - reference to world object instance
//!return (boolean) whether the tile is considered to be valid.
var function validDoorTile(xpos, ypos, player_id, world) {
  var th = TheApp.map.th;
  var tile_flags = th->getCellFlags(xpos, ypos);
  // check own it
  if( tile_flags.owner != player_id ) { return false; }
  // any object will cause it to be blocked (ignore litter)
  if( tile_flags.thob != 0 && tile_flags.thob != 62 ) { return false; }
  // check if its passable that no object footprint blocks it
  if( tile_flags.passable ) { return world->isTileExclusivelyPassable(xpos, ypos, 1); }
  return true;
}

//! Calculate position offsets and door blueprint wall values
//! param x (int) doors blueprint x value
//! param y (int) doors blueprint y value
//! param wall (string) original wall orientation
//! return x (int) updated x value
//! return y (int) updated y value
//! return x_mod (int) offest value to apply to tile count to determine relative position
//! return y_mod (int) offset value to apply to tile count to determine relatitve position
//! return wall (string) wall orientation style (only 2 styles)
var function doorWallOffsetCalculations(x, y, wall) {
  var x_mod;
  var y_mod;
  if( wall == "south" ) {
    ++y    ;
    wall = "north";
    x_mod = 2;
  } else if( wall == "east" ) {
    ++x    ;
    wall = "west";
    y_mod = 2;
  } else if( wall == "north" ) {
    x_mod = 2;
  } else {
    y_mod = 2;
  }
  return x, y, x_mod, y_mod, wall;
}

function UIEditRoom::setDoorBlueprint(orig_x, orig_y, orig_wall) {
  var x, y, x_mod, y_mod, wall = doorWallOffsetCalculations(orig_x, orig_y, orig_wall);
  var map = TheApp.map.th;

  if( this.blueprint_door.anim ) {
    if( this.room_type.swing_doors ) {
      if( this.blueprint_door.anim[1] ) {
        // retrieve the old door position details to reset the blue print
        var oldx, oldy;
		var _, _, oldx_mod, oldy_mod, _ = doorWallOffsetCalculations(this.blueprint_door.floor_x,
          this.blueprint_door.floor_y, this.blueprint_door.wall);
        // If we're dealing with swing doors the anim variable is actually a table with three
        // identical "doors".
        for( i, anim in ipairs(this.blueprint_door.anim) ) {
          anim->setAnimation(this.anims, this.blueprint_door.old_anim[i],
            this.blueprint_door.old_flags[i]);
          anim->setTag(null);
          this.blueprint_door.anim[i] = null;
          oldx = oldx_mod && this.blueprint_door.floor_x + (i - oldx_mod) || this.blueprint_door.floor_x;
          oldy = oldy_mod && this.blueprint_door.floor_y + (i - oldy_mod) || this.blueprint_door.floor_y;
          map->setCell(oldx, oldy, 4, 24);
        }
      }
    } else {
      this.blueprint_door.anim->setAnimation(this.anims, this.blueprint_door.old_anim,
        this.blueprint_door.old_flags);
      this.blueprint_door.anim->setTag(null);
      this.blueprint_door.anim = null;
      map->setCell(this.blueprint_door.floor_x, this.blueprint_door.floor_y, 4, 24);
    }
  }
  this.blueprint_door.x = x;
  this.blueprint_door.y = y;
  this.blueprint_door.wall = wall;
  this.blueprint_door.floor_x = orig_x;
  this.blueprint_door.floor_y = orig_y;
  this.blueprint_door.valid = false;
  if( ! wall ) {
    return;
  }
  var anim = this.blueprint_wall_anims[x][y];
  if( this.room_type.swing_doors ) {
    anim = {};
    var types = {"swing_slave", "swing_master", "nothing"};
    for( i = 1, 3 ) {
      var x1 = x_mod && (x + (i - x_mod)) || x;
      var y1 = y_mod && (y + (i - y_mod)) || y;
      anim[i] = this.blueprint_wall_anims[x1][y1];
      if( anim[i] != this.blueprint_door.anim[i] ) {
        this.blueprint_door.anim[i] = anim[i];
        this.blueprint_door.anim[i]->setTag(types[i]);
        this.blueprint_door.old_anim[i] = anim[i]->getAnimation();
        this.blueprint_door.old_flags[i] = anim[i]->getFlag();
      }
    }
  } else {
    if( anim != this.blueprint_door.anim ) {
      this.blueprint_door.anim = anim;
      this.blueprint_door.anim->setTag("door");
      this.blueprint_door.old_anim = anim->getAnimation();
      this.blueprint_door.old_flags = anim->getFlag();
    }
  }

  var flags;
  var x2, y2 = x, y;
  if( wall == "west" ) {
    flags = 1;
    --x2    ;
  } else {//if wall == "north" then
    flags = 0;
    --y2    ;
  }
  var world = this.ui.app.world;
  // invalid_tile used to select the individual blueprint that is blocked
  var invalid_tile = checkDoorWalls(x, y, wall, this.room_type.swing_doors);
  // Ensure that the door isn't being built on top of an object
  var player_id = this.ui.hospital->getPlayerIndex();
  if( ! validDoorTile(x, y, player_id, world) ||
      ! validDoorTile(x2, y2, player_id, world) ) {
    invalid_tile = bitOr(invalid_tile, 4);
  }
  // If we're making swing doors two more tiles need to be checked.
  if( this.room_type.swing_doors ) {
    var dx = x_mod && 1 || 0;
    var dy = y_mod && 1 || 0;
    if( ! validDoorTile(x + dx, y + dy, player_id, world) ||
        ! validDoorTile(x2 + dx, y2 + dy, player_id, world) ) {
      invalid_tile = bitOr(invalid_tile, 8);
    }
    if( ! validDoorTile(x - dx, y - dy, player_id, world) ||
        ! validDoorTile(x2 - dx, y2 - dy, player_id, world) ) {
      invalid_tile = bitOr(invalid_tile, 2);
    }
  }

  this.blueprint_door.valid = (invalid_tile == 0);

  if( this.room_type.swing_doors ) {
    for( i, animation in ipairs(anim) ) {
      // calculation here to flag blocked blueprint tiles on swing doors for each door tile
      animation->setAnimation(this.anims, 126, flags + (hasBit(invalid_tile, i) && 1 || 0) * 16);
    }
  } else {
    anim->setAnimation(this.anims, 126, flags + (invalid_tile != 0 && 1 || 0) * 16);
  }
  if( this.room_type.swing_doors ) {
    flags = door_floor_blueprint_markers[orig_wall];
    var dirfix = orig_wall == "east";
    flags = dirfix && flags + 1 || flags;
    for( i = 1, 3 ) {
      var x1 = x_mod && orig_x + i - x_mod || orig_x;
      var y1 = y_mod && orig_y + i - y_mod || orig_y;
      if( (i == 2) ) {
        map->setCell(x1, y1, 4, 24);
      } else {
        if( dirfix ) {
          map->setCell(x1, y1, 4, i < 2 && flags || flags - 1);
        } else {
          map->setCell(x1, y1, 4, i > 2 && flags || flags - 1);
        }
      }
    }
  } else {
    map->setCell(this.blueprint_door.floor_x, this.blueprint_door.floor_y, 4,
      door_floor_blueprint_markers[orig_wall]);
  }
}

function UIEditRoom::placeWindowBlueprint() {
  if( this.blueprint_window.anim && this.blueprint_window.valid ) {
    this.blueprint_window = {};
    this.ui->playSound("buildclk.wav");
  } else if( this.blueprint_window.anim && ! this.blueprint_window.valid ) {
    this.ui->tutorialStep(3, 11, 12);
  }
}

function UIEditRoom::setWindowBlueprint(orig_x, orig_y, orig_wall) {
  var x = orig_x;
  var y = orig_y;
  var wall = orig_wall;

  if( wall == "south" ) {
    ++y    ;
    wall = "north";
  } else if( wall == "east" ) {
    ++x    ;
    wall = "west";
  }

  var map = this.ui.app.map.th;
  var world = this.ui.app.world;

  if( this.blueprint_window.anim ) {
    this.blueprint_window.anim->setAnimation(this.anims, this.blueprint_window.old_anim,
      this.blueprint_window.old_flags);
      this.blueprint_window.anim->setTag(null);
    this.blueprint_window.anim = null;
    map->setCell(this.blueprint_window.floor_x, this.blueprint_window.floor_y, 4, 24);
  }

  var anim = x && this.blueprint_wall_anims[x][y];
  if( anim && anim->getTag() ) {
    x, y, wall = null, null, null;
    orig_x, orig_y, orig_wall = null, null, null;
  }

  this.blueprint_window.x = x;
  this.blueprint_window.y = y;
  this.blueprint_window.wall = wall;
  this.blueprint_window.floor_x = orig_x;
  this.blueprint_window.floor_y = orig_y;
  this.blueprint_window.valid = false;
  if( ! wall ) {
    return;
  }

  if( anim != this.blueprint_window.anim ) {
    this.blueprint_window.anim = anim;
    this.blueprint_window.anim->setTag("window");
    this.blueprint_window.old_anim = anim->getAnimation();
    this.blueprint_window.old_flags = anim->getFlag();
  }
  this.blueprint_window.valid = true;
  var flags;
  if( wall == "west" ) {
    flags = 1;
    if( world->getWallIdFromBlockId(map->getCell(x, y, 3)) ) {
      this.blueprint_window.valid = false;
      flags +=   16;
    }
  } else {//if wall == "north" then
    flags = 0;
    if( world->getWallIdFromBlockId(map->getCell(x, y, 2)) ) {
      this.blueprint_window.valid = false;
      flags +=   16;
    }
  }
  anim->setAnimation(this.anims, 130, flags);
  if( this.blueprint_window.valid ) {
    map->setCell(this.blueprint_window.floor_x, this.blueprint_window.floor_y, 4,
      window_floor_blueprint_markers[orig_wall]);
  }
}

function UIEditRoom::onCursorWorldPositionChange(x, y) {
  var repaint = UIPlaceObjects.onCursorWorldPositionChange(this, x, y);

  var ui = this.ui;

  // Is the game paused?
  if( ! this.world.user_actions_allowed || this.confirm_dialog_open ) {
    ui->setCursor(ui.default_cursor);
    return;
  }
  var wx, wy = ui->ScreenToWorld(this.x + x, this.y + y);
  wx = math.floor(wx);
  wy = math.floor(wy);

  if( this.phase == "walls" ) {
    var rect = this.blueprint_rect;
    if( ! this.mouse_down_x ) {
      if( wx > rect.x && wx < rect.x + rect.w - 1 && wy > rect.y && wy < rect.y + rect.h - 1 ) {
        // inside blueprint, non-border -> move blueprint
        ui->setCursor(ui.app.gfx->loadMainCursor("move_room"));
        this.move_rect = true;
        this.resize_rect = false;
      } else if( wx < rect.x || wx >= rect.x + rect.w || wy < rect.y || wy >= rect.y + rect.h ) {
        // outside blueprint
        ui->setCursor(ui.app.gfx->loadMainCursor("resize_room"));
        this.move_rect = false;
        this.resize_rect = false;
      } else {
        // inside blueprint, at border -> resize blueprint
        this.move_rect = false;
        this.resize_rect = {
          n = (wy == rect.y),
          s = (wy == rect.y + rect.h - 1) && ! (wy == rect.y),
          w = (wx == rect.x),
          e = (wx == rect.x + rect.w - 1) && ! (wx == rect.x),
        };

        if( (this.resize_rect.w || this.resize_rect.e) && (this.resize_rect.n || this.resize_rect.s) ) {
          ui->setCursor(ui.app.gfx->loadMainCursor("nswe_arrow"));
        } else if( this.resize_rect.w || this.resize_rect.e ) {
          ui->setCursor(ui.app.gfx->loadMainCursor("we_arrow"));
        } else {
          ui->setCursor(ui.app.gfx->loadMainCursor("ns_arrow"));
        }
      }
    }
  } else {
    if( this.phase != "clear_area" && this.phase != "objects" ) {
      ui->setCursor(ui.app.gfx->loadMainCursor("resize_room"));
    }
    var cell_x, cell_y, wall = this->screenToWall(this.x + x, this.y + y);
    if( this.phase == "door" ) {
      this->setDoorBlueprint(cell_x, cell_y, wall);
    } else if( this.phase == "windows" ) {
      this->setWindowBlueprint(cell_x, cell_y, wall);
    }
  }

  if( this.mouse_down_x && this.move_rect ) {
    var rect = this.blueprint_rect;
    this->setBlueprintRect(wx - this.move_rect_x, wy - this.move_rect_y, rect.w, rect.h);
  } else if( this.mouse_down_x && this.resize_rect ) {
    var rect = this.blueprint_rect;
    var x1, y1, x2, y2 = rect.x, rect.y, rect.x + rect.w - 1, rect.y + rect.h - 1;
    if( this.resize_rect.w ) {
      x1 = wx;
    } else if( this.resize_rect.e ) {
      x2 = wx;
    }
    if( this.resize_rect.n ) {
      y1 = wy;
    } else if( this.resize_rect.s ) {
      y2 = wy;
    }

    if( x1 > x2 ) {
      x1, x2 = x2, x1;
      this.resize_rect.w, this.resize_rect.e = this.resize_rect.e, this.resize_rect.w;
    }
    if( y1 > y2 ) {
      y1, y2 = y2, y1;
      this.resize_rect.n, this.resize_rect.s = this.resize_rect.s, this.resize_rect.n;
    }
    this->setBlueprintRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);
  } else if( this.mouse_down_x ) {
    var x1, x2 = this.mouse_down_x, wx;
    var y1, y2 = this.mouse_down_y, wy;
    if( x1 > x2 ) { x1, x2 = x2, x1; }
    if( y1 > y2 ) { y1, y2 = y2, y1; }
    this->setBlueprintRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);
  }

  if( wx != this.mouse_cell_x || wy != this.mouse_cell_y ) {
    repaint = true;
  }
  this.mouse_cell_x = wx;
  this.mouse_cell_y = wy;

  return repaint;
}

// checks if all required objects are placed, and enables/disables the confirm button accordingly.
// also returns the new state of the confirm button
function UIEditRoom::checkEnableConfirm() {
  var needed = {}; // copy list of required objects
  for( k, v in pairs(this.room.room_info.objects_needed) ) {
    needed[k] = v;
  }

  // subtract existing objects from the required numbers
  for( o in pairs(this.room.objects) ) {
    var id = o.object_type.id;
    if( needed[id] ) {
      needed[id] = needed[id] - 1;
      if( needed[id] == 0 ) {
        needed[id] = null;
      }
    }
  }

  // disable if there are not fulfilled requirements
  var confirm = ! next(needed);

  if( confirm ) {
    this.ui->tutorialStep(3, {13, 14}, 15);
  } else {
    this.ui->tutorialStep(3, {14, 15}, 13);
  }

  this.confirm_button->enable(confirm);
  return confirm;
}

function UIEditRoom::placeObject() {
  var obj = UIPlaceObjects.placeObject(this, true);
  if( obj ) {
    this->checkEnableConfirm();
  }
}

function UIEditRoom::afterLoad(old, new) {
  if( old < 101 ) {
    this->removeKeyHandler("enter");
    this->addKeyHandler("return", this.confirm);
  }
  if( old < 104 ) {
    this->addKeyHandler("keypad enter", this.confirm);
  }
}
