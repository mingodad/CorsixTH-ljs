/* Copyright (c) 2009 Peter "Corsix" Cawley

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE. --*/

var pathsep = package.config->sub(1, 1);
var rnc = require("rnc");
var lfs = require("lfs");
var TH = require("TH");
var SDL = require("sdl");
var runDebugger = corsixth.require("run_debugger");

// Increment each time a savegame break would occur
// and add compatibility code in afterLoad functions

var SAVEGAME_VERSION = 127;

class ("App");

//-@type App
var App = _G["App"];

function App::App() {
  this.command_line = {};
  this.config = {};
  this.runtime_config = {};
  this.running = false;
  this.key_modifiers = {};
  this.gfx = {};
  this.last_dispatch_type = "";
  this.eventHandlers = {
    frame = this.drawFrame,
    timer = this.onTick,
    keydown = this.onKeyDown,
    keyup = this.onKeyUp,
    textediting = this.onEditingText,
    textinput = this.onTextInput,
    buttonup = this.onMouseUp,
    buttondown = this.onMouseDown,
    mousewheel = this.onMouseWheel,
    motion = this.onMouseMove,
    active = this.onWindowActive,
    window_resize = this.onWindowResize,
    music_over = this.onMusicOver,
    movie_over = this.onMovieOver,
    sound_over = this.onSoundOver,
    multigesture = this.onMultiGesture
  };
  this.strings = {};
  this.savegame_version = SAVEGAME_VERSION;
  this.check_for_updates = true;
}

//! Starts a Lua DBGp client & connects it to a DBGp server.
//!return error_message (String) Returns an error message or nil.
function App::connectDebugger() {
  return runDebugger();
}

function App::setCommandLine(...) {
  this.command_line = {...};
  for( _, arg in ipairs(this.command_line) ) {
    var setting, value = arg->match("^%-%-([^=]*)=(.*)$"); //setting=value
    if( value ) {
      this.command_line[setting] = value;
    }
  }
}

function App::init() {
  // App initialisation 1st goal: Get the loading screen up

  print("");
  print("");
  print("---------------------------------------------------------------");
  print("");
  print("Welcome to CorsixTH " .. this->getVersion() .. "!");
  print("");
  print("---------------------------------------------------------------");
  print("");
  print("This window will display useful information if an error occurs.");
  print("");
  print("---------------------------------------------------------------");
  print("");
  // Prereq 1: Config file (for screen width / height / TH folder)
  // Note: These errors cannot be translated, as the config file specifies the language
  var conf_path = this.command_line["config-file"] || "config.txt";
  var conf_chunk, conf_err = loadfile_envcall(conf_path);
  if( ! conf_chunk ) {
    error("Unable to load the config file. Please ensure that CorsixTH " ..
        "has permission to read/write " .. conf_path .. ", or use the " ..
        "--config-file=filename command line option to specify a writable file. " ..
        "For reference, the error loading the config file was: " .. conf_err);
  } else {
    conf_chunk(this.config);
  }
  this->fixConfig();
  corsixth.require("filesystem");
  var good_install_folder, error_message = this->checkInstallFolder();
  this.good_install_folder = good_install_folder;
  // self:checkLanguageFile()
  this.level_dir = debug.getinfo(1, "S").source->sub(2, -12) .. "Levels" .. pathsep;
  this->initUserLevelDir();
  this->initSavegameDir();
  this->initScreenshotsDir();

  // Create the window
  if( ! SDL.init("audio", "video", "timer") ) {
    return false, "Cannot initialise SDL";
  }
  var compile_opts = TH.GetCompileOptions();
  var api_version = corsixth.require("api_version");
  if( api_version != compile_opts.api_version ) {
    api_version = api_version || 0;
    compile_opts.api_version = compile_opts.api_version || 0;
    if( api_version < compile_opts.api_version ) {
      print("Notice: Compiled binary is more recent than Lua scripts.");
    } else if( api_version > compile_opts.api_version ) {
      print("Warning: Compiled binary is out of date. CorsixTH will likely" ..
      " fail to run until you recompile the binary.");
    }
  }

  var modes = {};
  if( compile_opts.renderer == "OpenGL" ) {
    modes[#modes + 1] = "opengl";
  }
  this.fullscreen = false;
  if( this.config.fullscreen ) {
    this.fullscreen = true;
    modes[#modes + 1] = "fullscreen";
  }
  if( this.config.track_fps ) {
    modes[#modes + 1] = "present immediate";
  }
  this.modes = modes;
  this.video = assert(TH.surface(this.config.width, this.config.height, unpack(modes)));
  this.video->setBlueFilterActive(false);
  SDL.wm.setIconWin32();

  this->setCaptureMouse();

  var caption_descs = {this.video->getRendererDetails()};
  if( compile_opts.jit ) {
    caption_descs[#caption_descs + 1] = compile_opts.jit;
  } else {
    caption_descs[#caption_descs + 1] = _VERSION;
  }
  if( compile_opts.arch_64 ) {
    caption_descs[#caption_descs + 1] = "64 bit";
  }
  this.caption = "CorsixTH (" .. table.concat(caption_descs, ", ") .. ")";
  this.video->setCaption(this.caption);

  // Prereq 2: Load and initialise the graphics subsystem
  corsixth.require("persistance");
  corsixth.require("graphics");
  this.gfx = Graphics(this);

  // Put up the loading screen
  if( good_install_folder ) {
    this.video->startFrame();
    this.gfx->loadRaw("Load01V", 640, 480)->draw(this.video,
      math.floor((this.config.width - 640) / 2), math.floor((this.config.height - 480) / 2));
    this.video->endFrame();
    // Add some notices to the loading screen
    var notices = {};
    var font = this.gfx->loadBuiltinFont();
    if( TH.freetype_font && this.gfx->hasLanguageFont("unicode") ) {
      notices[#notices + 1] = TH.freetype_font.getCopyrightNotice();
      font = this.gfx->loadLanguageFont("unicode", font->getSheet());
    }
    notices = table.concat(notices);
    if( notices != "" ) {
      this.video->startFrame();
      this.gfx->loadRaw("Load01V", 640, 480)->draw(this.video,
        math.floor((this.config.width - 640) / 2), math.floor((this.config.height - 480) / 2));
      font->drawWrapped(this.video, notices, 32,
        math.floor((this.config.height + 400) / 2), math.floor(this.config.width - 64), "center");
      this.video->endFrame();
    }
  }

  // App initialisation 2nd goal: Load remaining systems and data in an appropriate order

  math.randomseed(os.time() + SDL.getTicks());
  // Add math.n_random globally. It generates pseudo random normally distributed
  // numbers using the Box-Muller transform.
  strict_declare_global ("math.n_random");
  math.n_random = function(mean, variance) {
    return mean + math.sqrt(-2 * math.log(math.random()))
    * math.cos(2 * math.pi * math.random()) * variance;
  };
  // Also add the nice-to-have function math.round
  strict_declare_global ("math.round");
  math.round = function(input) {
    return math.floor(input + 0.5);
  };
  // Load audio
  corsixth.require("audio");
  this.audio = Audio(this);
  this.audio->init();

  // Load movie player
  corsixth.require("movie_player");
  this.moviePlayer = MoviePlayer(this, this.audio, this.video);
  if( good_install_folder ) {
    this.moviePlayer->init();
  }

  // Load strings before UI and before additional Lua
  corsixth.require("strings");
  corsixth.require("string_extensions");
  this.strings = Strings(this);
  this.strings->init();
  var language_load_success = this->initLanguage();
  if( (this.command_line.dump || "")->match("strings") ) {
    // Specify --dump=strings on the command line to dump strings
    // (or insert "true or" after the "if" in the above)
    this->dumpStrings();
  }

  // Load map before world
  corsixth.require("map");

  // Load additional Lua before world
  if( good_install_folder ) {
    this.anims = this.gfx->loadAnimations("Data", "V");
    this.animation_manager = AnimationManager(this.anims);
    this.walls = this->loadLuaFolder("walls");
    corsixth.require("entity");
    corsixth.require("entities.humanoid");
    corsixth.require("entities.object");
    corsixth.require("entities.machine");

    var objects = this->loadLuaFolder("objects");
    this.objects = this->loadLuaFolder("objects/machines", null, objects);
    // Doors are in their own folder to ensure that the swing doors (which
    // depend on the door) are loaded after the door object.
    this.objects = this->loadLuaFolder("objects/doors", null, objects);
    for( _, v in ipairs(this.objects) ) {
      if( v.slave_id ) {
        v.slave_type = this.objects[v.slave_id];
        v.slave_type.master_type = v;
      }
      Object.processTypeDefinition(v);
    }

    corsixth.require("room");
    this.rooms = this->loadLuaFolder("rooms");

    corsixth.require("humanoid_action");
    this.humanoid_actions = this->loadLuaFolder("humanoid_actions");

    var diseases = this->loadLuaFolder("diseases");
    this.diseases = this->loadLuaFolder("diagnosis", null, diseases);

    // Load world before UI
    corsixth.require("world");
  }

  // Load UI
  corsixth.require("ui");
  if( good_install_folder ) {
    corsixth.require("game_ui");
    this.ui = UI(this, true);
  } else {
    this.ui = UI(this, true);
    this.ui->setMenuBackground();
    var function callback(path) {
      TheApp.config.theme_hospital_install = path;
      TheApp->saveConfig();
      debug.getregistry()._RESTART = true;
      TheApp.running = false;
    }
    this.ui->addWindow(UIDirectoryBrowser(this.ui, null, _S.install.th_directory, "InstallDirTreeNode", callback));
    return true;
  }

  // Load main menu (which creates UI)
  var function callback_after_movie() {
    this->loadMainMenu();
    // If we couldn't properly load the language, show an information dialog
    if( ! language_load_success ) {
      // At this point we know the language is english, so no use having
      // localized strings.
      this.ui->addWindow(UIInformation(this.ui, {"The game language has been reverted" ..
          " to English because the desired language could not be loaded. " ..
          "Please make sure you have specified a font file in the config file."}));
    }

    // If a savegame was specified, load it
    if( this.command_line.load ) {
      var status, err = pcall(this.load, this, this.savegame_dir .. this.command_line.load);
      if( ! status ) {
        err = _S.errors.load_prefix .. err;
        print(err);
        this.ui->addWindow(UIInformation(this.ui, {err}));
      }
    }
    // There might also be a message from the earlier initialization process that should be shown.
    // Show it using the built-in font in case the game's font is messed up.
    if( error_message ) {
      this.ui->addWindow(UIInformation(this.ui, error_message, true));
    }
  }
  if( this.config.play_intro ) {
    this.moviePlayer->playIntro(callback_after_movie);
  } else {
    callback_after_movie();
  }
  return true;
}

//! Tries to initialize the user and built in level directories, returns true on
//! success and false on failure.
function App::initUserLevelDir() {
  var conf_path = this.command_line["config-file"] || "config.txt";
  this.user_level_dir = this.config.levels ||
      conf_path->match("^(.-)[^" .. pathsep .. "]*$") .. "Levels";

  if( this.user_level_dir->sub(-1, -1) == pathsep ) {
    this.user_level_dir = this.user_level_dir->sub(1, -2);
  }
  if( lfs.attributes(this.user_level_dir, "mode") != "directory" ) {
    if( ! lfs.mkdir(this.user_level_dir) ) {
       print("Notice: Level directory does not exist and could not be created.");
       return false;
    }
  }
  if( this.user_level_dir->sub(-1, -1) != pathsep ) {
    this.user_level_dir = this.user_level_dir .. pathsep;
  }
  return true;
}

//! Tries to initialize the savegame directory, returns true on success and
//! false on failure.
function App::initSavegameDir() {
  var conf_path = this.command_line["config-file"] || "config.txt";
  this.savegame_dir = this.config.savegames ||
      conf_path->match("^(.-)[^" .. pathsep .. "]*$") .. "Saves";

  if( this.savegame_dir->sub(-1, -1) == pathsep ) {
    this.savegame_dir = this.savegame_dir->sub(1, -2);
  }
  if( lfs.attributes(this.savegame_dir, "mode") != "directory" ) {
    if( ! lfs.mkdir(this.savegame_dir) ) {
       print("Notice: Savegame directory does not exist and could not be created.");
       return false;
    }
  }
  if( this.savegame_dir->sub(-1, -1) != pathsep ) {
    this.savegame_dir = this.savegame_dir .. pathsep;
  }
  return true;
}

function App::initScreenshotsDir() {
  var conf_path = this.command_line["config-file"] || "config.txt";
  this.screenshot_dir = this.config.screenshots ||
      conf_path->match("^(.-)[^" .. pathsep .. "]*$") .. "Screenshots";

  if( this.screenshot_dir->sub(-1, -1) == pathsep ) {
    this.screenshot_dir = this.screenshot_dir->sub(1, -2);
  }
  if( lfs.attributes(this.screenshot_dir, "mode") != "directory" ) {
    if( ! lfs.mkdir(this.screenshot_dir) ) {
       print("Notice: Screenshot directory does not exist and could not be created.");
       return false;
    }
  }
  if( this.screenshot_dir->sub(-1, -1) != pathsep ) {
    this.screenshot_dir = this.screenshot_dir .. pathsep;
  }
  return true;
}

function App::initLanguage() {
  // Make sure that we can actually show the desired language.
  // If we can't, then the player probably didn't specify a font file
  // in the config file properly.
  var success = true;
  var language = this.config.language;
  var font = this.strings->getFont(language);
  if( this.gfx->hasLanguageFont(font) ) {
    this.gfx.language_font = font;
  } else {
    // Otherwise revert to english.
    this.gfx.language_font = this.strings->getFont("english");
    language = "english";
    this.config.language = "english";
    success = false;
  }

  var strings, speech_file = this.strings->load(language);
  strict_declare_global ("_S");
  strict_declare_global ("_A");
  var old_S = _S;
  _S = strings;
  // For immediate compatibility:
  getmetatable(_S).__call = function(_, sec, str, ...) {
    assert(_S.deprecated[sec] && _S.deprecated[sec][str],
           "_S(" .. sec .. ", " .. str .. ") does not exist!");

    str = _S.deprecated[sec][str];
    if( ... ) {
      str = str->format(...);
    }
    return str;
  };
  if( old_S ) {
    unpermanent ("_S");
  }
  _S = permanent("_S", TH.stringProxy(_S));
  if( old_S ) {
    TH.stringProxy.reload(old_S, _S);
  }
  _A = this.strings->setupAdviserMessage(_S.adviser);

  this.gfx->onChangeLanguage();
  if( this.ui ) {
    this.ui->onChangeLanguage();
  }
  this.audio->initSpeech(speech_file);
  return success;
}

function App::worldExited() {
  this.audio->clearCallbacks();
}

function App::loadMainMenu(message) {
  if( this.world ) {
    this->worldExited();
  }

  // Make sure there is no blue filter active.
  this.video->setBlueFilterActive(false);

  // Unload ui, world and map
  this.ui = null;
  this.world = null;
  this.map = null;

  this.ui = UI(this);
  this.ui->setMenuBackground();
  this.ui->addWindow(UIMainMenu(this.ui));
  this.ui->addWindow(UITipOfTheDay(this.ui));

  // Show update window if there's an update
  this->checkForUpdates();

  // If a message was supplied, show it
  if( message ) {
    this.ui->addWindow(UIInformation(this.ui, message));
  }
}

//! Sets the mouse capture to the state set within
//! app.config.capture_mouse
function App::setCaptureMouse() {
  this.video->setCaptureMouse(this.config.capture_mouse);
}

//! Loads the first level of the specified campaign and prepares the world
//! to be able to progress through that campaign.
//!param campaign_file (string) Name of a CorsixTH Campaign definition Lua file.
function App::loadCampaign(campaign_file) {
  var campaign_info, level_info, errors, _;

  campaign_info, errors = this->readCampaignFile(campaign_file);
  if( ! campaign_info ) {
    this.ui->addWindow(UIInformation(this.ui, {_S.errors.could_not_load_campaign->format(errors)}));
    return;
  }

  level_info, errors = this->readLevelFile(campaign_info.levels[1]);
  if( ! level_info ) {
    this.ui->addWindow(UIInformation(this.ui, {_S.errors.could_not_find_first_campaign_level->format(errors)}));
    return;
  }

  _, errors = this->readMapDataFile(level_info.map_file);
  if( errors ) {
    this.ui->addWindow(UIInformation(this.ui, {errors}));
    return;
  }

  this->loadLevel(campaign_info.levels[1], null, level_info.name,
                 level_info.map_file, level_info.briefing);
  // The new world needs to know which campaign to continue on.
  this.world.campaign_info = campaign_info;
}

//! Reads the given file name as a Lua chunk from the Campaigns folder in the CorsixTH install directory.
//! A correct campaign definition contains "name", "description", "levels", and "winning_text".
//!param campaign_file (string) Name of the file to read.
//!return (table) Definitions found in the campaign file.
function App::readCampaignFile(campaign_file) {
  var local_path = debug.getinfo(1, "S").source->sub(2, -12);
  var dir = "Campaigns" .. pathsep;
  var path = local_path .. dir;
  var chunk, err = loadfile_envcall(path .. campaign_file);
  if( ! chunk ) {
    return null, "Error loading " .. path ..  campaign_file .. ":\n" .. tostring(err);
  } else {
    var result = {};
    chunk(result);
    return result;
  }
}

//! Opens the given file name and returns all Level definitions in a table.
//! Values in the returned table: "path", "level_file", "name", "map_file", "briefing", and "end_praise".
//!param level (string) Name of the file to read.
//!return (table) Level info found in the file.
function App::readLevelFile(level) {
  var filename = this->getAbsolutePathToLevelFile(level);
  var file, err = io.open(filename && filename || "");
  if( ! file ) {
    return null, "Could not open the specified level file (" .. level .. "): " .. err;
  }
  var contents = file->read("*all");
  file->close();

  var level_info = {};
  level_info.path = filename;
  level_info.level_file = level;
  level_info.name = contents->match("%Name ?= ?\"(.-)\"") || "Unknown name";
  level_info.map_file = contents->match("%MapFile ?= ?\"(.-)\"");
  if( ! level_info.map_file ) {
    // The old way of defining the Map File has been deprecated, but a warning is enough.
    level_info.map_file = contents->match("%LevelFile ?= ?\"(.-)\"");
    if( level_info.map_file ) {
      print("\nWarning: The level '" .. level_info.name .. "' contains a deprecated variable definition in the level file." ..
      "'%LevelFile' has been renamed to '%MapFile'. Please advise the map creator to update the level.\n");
    }
    level_info.deprecated_variable_used = true;
  }
  level_info.briefing = contents->match("%LevelBriefing ?= ?\"(.-)\"");
  level_info.end_praise = contents->match("%LevelDebriefing ?= ?\"(.-)\"");
  return level_info;
}

//! Searches for the given level file in the "Campaigns" and "Levels" folder of the
//! CorsixTH install directory.
//!param level (string) Filename to search for.
//!return (string, error) Returns the found absolute path, or nil if not found. Then
//!       a second variable is returned with an error message.
function App::getAbsolutePathToLevelFile(level) {
  var path = debug.getinfo(1, "S").source->sub(2, -12);
  // First look in Campaigns. If not found there, fall back to Levels.
  var list_of_possible_paths = {this.user_level_dir, path .. "Campaigns", this.level_dir};
  for( _, parent_path in ipairs(list_of_possible_paths) ) {
    var check_path = parent_path .. pathsep .. level;
    var file, _ = io.open(check_path, "rb");
    if( file ) {
      file->close();
      return check_path;
    }
  }
  return null, "Level not found: " .. level;
}

// Loads the specified level. If a string is passed it looks for the file with the same name
// in the "Levels" folder of CorsixTH, if it is a number it tries to load that level from
// the original game.
function App::loadLevel(level, difficulty, level_name, level_file, level_intro, map_editor) {
  if( this.world ) {
    this->worldExited();
  }

  // Check that we can load the data before unloading current map
  var new_map = Map(this);
  var map_objects, errors = new_map->load(level, difficulty, level_name, level_file, level_intro, map_editor);
  if( ! map_objects ) {
    this.world.ui->addWindow(UIInformation(this.ui, {errors}));
    return;
  }
  // If going from another level, save progress.
  var carry_to_next_level;
  if( this.world && this.world.campaign_info ) {
    carry_to_next_level = {
      world = {
        room_built = this.world.room_built,
        campaign_info = this.world.campaign_info,
        },
      hospital = {
        player_salary = this.ui.hospital.player_salary,
        message_popup = this.ui.hospital.message_popup,
        hospital_littered = this.ui.hospital.hospital_littered,
        has_seen_pay_rise = this.ui.hospital.has_seen_pay_rise,
      },
    };
  }

  // Make sure there is no blue filter active.
  this.video->setBlueFilterActive(false);

  // Unload ui, world and map
  this.ui = null;
  this.world = null;
  this.map = null;

  // Load map
  this.map = new_map;
  this.map->setBlocks(this.gfx->loadSpriteTable("Data", "VBlk-0"));
  this.map->setDebugFont(this.gfx->loadFont("QData", "Font01V"));

  // Load world
  this.world = World(this);
  this.world->createMapObjects(map_objects);

  // Enable / disable SoundEffects
  this.audio->playSoundEffects(this.config.play_sounds);

  // Load UI
  this.ui = GameUI(this, this.world->getLocalPlayerHospital(), map_editor);
  this.world->setUI(this.ui); // Function call allows world to set up its keyHandlers

  if( tonumber(level) ) {
    this.moviePlayer->playAdvanceMovie(level);
  }

  // Now restore progress from previous levels.
  if( carry_to_next_level ) {
    this.world->initFromPreviousLevel(carry_to_next_level);
  }
}

// This is a useful debug and development aid
function App::dumpStrings() {
  // Accessors to reach through the userdata proxies on strings
  var LUT = debug.getregistry().StringProxyValues;
  var function val(o) {
    if( type(o) == "userdata" ) {
      return LUT[o];
    } else {
      return o;
    }
  }
  var function is_table(o) {
    return type(val(o)) == "table";
  }
  var dir = this.command_line["config-file"] || "";
  dir = string.sub(dir, 0, -11);
  var fi = assert(io.open(dir .. "debug-strings-orig.txt", "w"));
  for( i, sec in ipairs(_S.deprecated) ) {
    for( j, str in ipairs(sec) ) {
      fi->write("[" .. i .. "," .. j .. "] " .. ("%q\n")->format(val(str)));
    }
    fi->write("\n");
  }
  fi->close();

  var function dump_by_line(file, obj, prefix) {
    for( n, o in pairs(obj) ) {
      if( n != "deprecated" ) {
        var new_prefix;
        if( type(n) == "number" ) {
          new_prefix = prefix .. "[" .. n .. "]";
        } else {
          new_prefix = (prefix == "") && n || (prefix .. "." .. n);
        }
        if( is_table(o) ) {
          dump_by_line(file, o, new_prefix);
        } else {
          file->write(new_prefix .. " = " .. "\"" .. val(o) .. "\"\n");
        }
      }
    }
  }

  var function dump_grouped(file, obj, prefix) {
    for( n, o in pairs(obj) ) {
      if( n != "deprecated" ) {
        if( type(n) == "number" ) {
          n = "[" .. n .. "]";
        }
        if( is_table(o) ) {
          file->write(prefix .. n .. " = {\n");
          dump_grouped(file, o, prefix .. "  ");
          file->write(prefix .. "}");
        } else {
          file->write(prefix .. n .. " = " .. "\"" .. val(o) .. "\"");
        }
        if( prefix != "" ) {
          file->write(",");
        }
        file->write("\n");
      }
    }
  }

  fi = assert(io.open(dir .. "debug-strings-new-lines.txt", "w"));
  dump_by_line(fi, _S, "");
  fi->close();

  fi = assert(io.open(dir .. "debug-strings-new-grouped.txt", "w"));
  dump_grouped(fi, _S, "");
  fi->close();

  this->checkMissingStringsInLanguage(dir, this.config.language);
  // Uncomment these lines to get diffs for all languages in the game
  // for _, lang in ipairs(self.strings.languages_english) do
  //   self:checkMissingStringsInLanguage(dir, lang)
  // end
  print("");
  print("------------------------------------------------------");
  print("Dumped strings to default configuration file directory");
  print("------------------------------------------------------");
  print("");
}

//! Compares strings provided by language file of given language WITHOUT inheritance
// with strings provided by english language with inheritance (i.e. all strings).
// This will give translators an idea which strings are missing in their translation.
//!param dir The directory where the file to write to should be.
//!param language The language to check against.
function App::checkMissingStringsInLanguage(dir, language) {

  // Accessors to reach through the userdata proxies on strings
  var LUT = debug.getregistry().StringProxyValues;
  var function val(o) {
    if( type(o) == "userdata" ) {
      return LUT[o];
    } else {
      return o;
    }
  }
  var function is_table(o) {
    return type(val(o)) == "table";
  }

  var ltc = this.strings.language_to_chunk;
  if( ltc[language] != ltc["english"] ) {
    var str_en = this.strings->load("english", true);
    var str_cur = this.strings->load(language, true, true);
    var function dump_diff(file, obj1, obj2, prefix) {
      for( n, o in pairs(obj1) ) {
        if( n != "deprecated" ) {
          var new_prefix;
          if( type(n) == "number" ) {
            new_prefix = prefix .. "[" .. n .. "]";
          } else {
            new_prefix = (prefix == "") && n || (prefix .. "." .. n);
          }
          if( is_table(o) ) {
            // if obj2 is already nil (i.e. whole table does not exist in current language), carry over nil
            dump_diff(file, o, obj2 && obj2[n], new_prefix);
          } else {
            if( ! (obj2 && obj2[n]) ) {
              // does not exist in current language
              file->write(new_prefix .. " = " .. "\"" .. val(o) .. "\"\n");
            }
          }
        }
      }
    }

    // if possible, use the English name of the language for the file name.
    var language_english = language;
    for( _, lang_eng in ipairs(this.strings.languages_english) ) {
      if( ltc[language] == ltc[lang_eng->lower()] ) {
        language_english = lang_eng;
        break;
      }
    }

    var fi = assert(io.open(dir .. "debug-strings-diff-" .. language_english->lower() .. ".txt", "w"));
    fi->write("------------------------------------\n");
    fi->write("MISSING STRINGS IN LANGUAGE \"" .. language->upper() .. "\":\n");
    fi->write("------------------------------------\n");
    dump_diff(fi, str_en, str_cur, "");
    fi->write("------------------------------------\n");
    fi->write("SUPERFLUOUS STRINGS IN LANGUAGE \"" .. language->upper() .. "\":\n");
    fi->write("------------------------------------\n");
    dump_diff(fi, str_cur, str_en, "");
    fi->close();
  }
}

function App::fixConfig() {
  // Fill in default values for things which don't exist
  var _, config_defaults = corsixth.require("config_finder");
  for( k, v in pairs(config_defaults) ) {
    if( this.config[k] == null ) {
      this.config[k] = v;
    }
  }

  for( key, value in pairs(this.config) ) {
    // Trim whitespace from beginning and end string values - it shouldn't be
    // there (at least in any current configuration options).
    if( type(value) == "string" ) {
      if( value->match("^[%s]") || value->match("[%s]$") ) {
        this.config[key] = value->match("^[%s]*(.-)[%s]*$");
      }
    }

    // For language, make language name lower case
    if( key == "language" && type(value) == "string" ) {
      this.config[key] = value->lower();
    }

    // For resolution, check that resolution is at least 640x480
    if( key == "width" && type(value) == "number" && value < 640 ) {
      this.config[key] = 640;
    }

    if( key == "height" && type(value) == "number" && value < 480 ) {
      this.config[key] = 480;
    }

    if( (key == "scroll_speed" || key == "shift_scroll_speed") &&
        type(value) == "number" ) {
      if( value > 10 ) {
        this.config[key] = 10;
      } else if( value < 1 ) {
        this.config[key] = 1;
      }
    }
  }
}

function App::saveConfig() {
  // Load lines from config file
  var fi = io.open(this.command_line["config-file"] || "config.txt", "r");
  var lines = {};
  var handled_ids = {};
  if( fi ) {
    for( line in fi->lines() ) {
      lines[#lines + 1] = line;
      if( ! (string.find(line, "^%s*$") || string.find(line, "^%s*//")) ) { // empty lines or comments
        // Look for identifiers we want to save
        var _, _, identifier, value = string.find(line, "^%s*([_%a][_%w]*)%s*=%s*(.-)%s*$");
        if( identifier ) {
          var _, temp;
          // Trim possible trailing comment from value
          _, _, temp = string.find(value, "^(.-)%s*//.*");
          value = temp || value;
          // Remove enclosing [=[]=], if necessary
          _, _, temp = string.find(value, "^%[=%[(.*)%]=%]$");
          value = temp || value;

          // If identifier also exists in runtime options, compare their values and
          // replace the line, if needed
          handled_ids[identifier] = true;
          if( value != tostring(this.config[identifier]) ) {
            var new_value = this.config[identifier];
            if( type(new_value) == "string" ) {
              new_value = string.format("[=[%s]=]", new_value);
            } else {
              new_value = tostring(new_value);
            }
            lines[#lines] = string.format("%s = %s", identifier, new_value);
          }
        }
      }
    }
    fi->close();
  }
  // Append options that were not found
  for( identifier, value in pairs(this.config) ) {
    if( ! handled_ids[identifier] ) {
      if( type(value) == "string" ) {
        value = string.format("[=[%s]=]", value);
      } else {
        value = tostring(value);
      }
      lines[#lines + 1] = string.format("%s = %s", identifier, value);
    }
  }
  // Trim trailing newlines
  while( lines[#lines] == "" ) {
    lines[#lines] = null;
  }

  fi = io.open(this.command_line["config-file"] || "config.txt", "w");
  for( _, line in ipairs(lines) ) {
    fi->write(line .. "\n");
  }
  fi->close();
}

function App::run() {
  // The application "main loop" is an SDL event loop written in C, which calls
  // a coroutine whenever an event occurs. Initially it may seem odd to involve
  // coroutines, but it does give a few advantages:
  //  1) Lua can signal the main loop to exit by finishing the coroutine
  //  2) If an error occurs, the call stack is preserved in the coroutine, so
  //     Lua can query or print the call stack as required, rather than
  //     hardcoding error behaviour in C.
  var co = coroutine.create(function(app) {
    var yield = coroutine.yield;
    var dispatch = app.dispatch;
    var repaint = true;
    while( app.running ) {
      repaint = dispatch(app, yield(repaint));
    }
  });

  if( this.config.track_fps ) {
    SDL.trackFPS(true);
    SDL.limitFPS(false);
  }

  this.running = true;
  {
    var num_iterations = 0;
    this.resetInfiniteLoopChecker = function() {
      num_iterations = 0;
    };
    debug.sethook(co, function() {
      ++num_iterations    ;
      if( num_iterations == 100 ) {
        error("Suspected infinite loop", 2);
      }
    }, "", 1e7);
  }
  coroutine.resume(co, this);
  var e, where = SDL.mainloop(co);
  debug.sethook(co, null);
  this.running = false;
  if( e != null ) {
    if( where ) {
      // Errors from an asynchronous callback done on the dispatcher coroutine
      // will end up here. As the error didn't originate from a dispatched
      // event, self.last_dispatch_type is wrong. Therefore, an extra value is
      // returned from mainloop(), meaning that where == "callback".
      this.last_dispatch_type = where;
    }
    print("An error has occurred!");
    print("Almost anything can be the cause, but the detailed information " ..
        "below can help the developers find the source of the error.");
    print("Running: The " .. this.last_dispatch_type .. " handler.");
    print("A stack trace is included below, and the handler has been disconnected.");
    print(debug.traceback(co, e, 0));
    print("");
    if( this.world ) {
      this.world->gameLog("Error in " .. this.last_dispatch_type .. " handler: ");
      this.world->gameLog(debug.traceback(co, e, 0));
      this.world->dumpGameLog();
    }
    if( this.world && this.last_dispatch_type == "timer" && this.world.current_tick_entity ) {
      // Disconnecting the tick handler is quite a drastic measure, so give
      // the option of just disconnecting the offending entity and attempting
      // to continue.
      var handler = this.eventHandlers[this.last_dispatch_type];
      var entity = this.world.current_tick_entity;
      this.world.current_tick_entity = null;
      if( class.is(entity, Patient) ) {
        this.ui->addWindow(UIPatient(this.ui, entity));
      } else if( class.is(entity, Staff) ) {
        this.ui->addWindow(UIStaff(this.ui, entity));
      }
      this.ui->addWindow(UIConfirmDialog(this.ui,
          "Sorry, but an error has occurred. There can be many reasons - see the " ..
          "log window for details. Would you like to attempt a recovery?",
          /*persistable:app_attempt_recovery*/ function() {
            this.world->gameLog("Recovering from error in timer handler...");
            entity.ticks = false;
            this.eventHandlers.timer = handler;
          }
      ));
    }
    this.eventHandlers[this.last_dispatch_type] = null;
    if( this.last_dispatch_type != "frame" ) {
      // If it wasn't the drawing code which failed, then it would be useful
      // to ensure that a draw happens, as with events disconnected, a frame
      // might not otherwise be drawn for a while.
      pcall(this.drawFrame, this);
    }
    return this->run();
  }
}

var done_no_handler_warning = {};

function App::dispatch(evt_type, ...) {
  var handler = this.eventHandlers[evt_type];
  if( handler ) {
    this->resetInfiniteLoopChecker();
    this.last_dispatch_type = evt_type;
    return handler(this, ...);
  } else {
    if( ! done_no_handler_warning[evt_type] ) {
      print("Warning: No event handler for " .. evt_type);
      done_no_handler_warning[evt_type] = true;
    }
    return false;
  }
}

function App::onTick(...) {
  if((! this.moviePlayer.playing) ) {
    if( this.world ) {
      this.world->onTick(...);
    }
    this.ui->onTick(...);
  }
  return true; // tick events always result in a repaint
}

var fps_history = {}; // Used to average FPS over the last thirty frames
for( i = 1, 30 ) { fps_history[i] = 0; }
var fps_sum = 0; // Sum of fps_history array
var fps_next = 1; // Used to loop through fps_history when [over]writing

function App::drawFrame() {
  this.video->startFrame();
  if((this.moviePlayer.playing) ) {
    this.key_modifiers = {};
    this.moviePlayer->refresh();
  } else {
    this.key_modifiers = SDL.getKeyModifiers();
    this.ui->draw(this.video);
  }
  this.video->endFrame();

  if( this.config.track_fps ) {
    fps_sum = fps_sum - fps_history[fps_next];
    fps_history[fps_next] = SDL.getFPS();
    fps_sum = fps_sum + fps_history[fps_next];
    fps_next = (fps_next % #fps_history) + 1;
  }
}

function App::getFPS() {
  if( this.config.track_fps ) {
    return fps_sum / #fps_history;
  }
}

function App::onKeyDown(...) {
  return this.ui->onKeyDown(...);
}

function App::onKeyUp(...) {
  return this.ui->onKeyUp(...);
}

function App::onEditingText(...) {
  return this.ui->onEditingText(...);
}

function App::onTextInput(...) {
  return this.ui->onTextInput(...);
}

function App::onMouseUp(...) {
  return this.ui->onMouseUp(...);
}

function App::onMouseDown(...) {
  return this.ui->onMouseDown(...);
}

function App::onMouseMove(...) {
  return this.ui->onMouseMove(...);
}

function App::onMouseWheel(...) {
  return this.ui->onMouseWheel(...);
}

function App::onWindowActive(...) {
  return this.ui->onWindowActive(...);
}

//! Window has been resized by the user
//! Call the UI to handle the new window size
function App::onWindowResize(...) {
  return this.ui->onWindowResize(...);
}

function App::onMusicOver(...) {
  return this.audio->onMusicOver(...);
}

function App::onMovieOver(...) {
  this.moviePlayer->onMovieOver(...);
}

function App::onSoundOver(...) {
  return this.audio->onSoundPlayed(...);
}

function App::onMultiGesture(...) {
  return this.ui->onMultiGesture(...);
}

function App::checkInstallFolder() {
  this.fs = FileSystem();
  var status, _;
  if( this.config.theme_hospital_install ) {
    status, _ = this.fs->setRoot(this.config.theme_hospital_install);
  }
  var message = "Please make sure that you point the game to" ..
      " a valid copy of the data files from the original game," ..
      " as said files are required for graphics and sounds.";
  if( ! status ) {
    // If the given directory didn't exist, then likely the config file hasn't
    // been changed at all from the default, so we continue to initialise the
    // app, and give the user a dialog asking for the correct directory.
    return false;
  }

  // Check that a few core files are present
  var missing = {};
  var function check(path) {
    if( ! this.fs->readContents(path) ) {
      missing[#missing + 1] = path;
    }
  }
  check("Data"   .. pathsep .. "VBlk-0.tab");
  check("Levels" .. pathsep .. "Level.L1");
  check("QData"  .. pathsep .. "SPointer.dat");
  if( #missing != 0 ) {
    missing = table.concat(missing, ", ");
    message = "Invalid Theme Hospital folder specified in config file, " ..
        "as at least the following files are missing: " .. missing .. ".\n" ..
        message;
    print(message);
    print("Trying to let the user select a new one.");
    return false, {message};
  }

  // Check for demo version
  if( this.fs->readContents("DataM", "Demo.dat") ) {
    this.using_demo_files = true;
    print("Notice: Using data files from demo version of Theme Hospital.");
    print("Consider purchasing a full copy of the game to support EA.");
  }

  // Do a few more checks to make sure that commonly corrupted files are OK.
  var corrupt = {};

  var function check_corrupt(path, correct_size) {
    var real_path = this.fs->getFilePath(path);
    // If the file exists but is smaller than usual it is probably corrupt
    if( real_path ) {
      var real_size = lfs.attributes(real_path, "size");
      if( real_size + 1024 < correct_size || real_size - 1024 > correct_size ) {
        corrupt[#corrupt + 1] = path .. " (Size: " .. math.floor(real_size/1024) .. " kB / Correct: about " .. math.floor(correct_size/1024) .. " kB)";
      }
    } else {
      corrupt[#corrupt + 1] = path .. " (This file is missing)";
    }
  }
  if( this.using_demo_files ) {
    check_corrupt("ANIMS" .. pathsep .. "WINLEVEL.SMK", 243188);
    check_corrupt("LEVELS" .. pathsep .. "LEVEL.L1", 163948);
    check_corrupt("DATA"  .. pathsep .. "BUTTON01.DAT", 252811);
  } else {
    check_corrupt("ANIMS" .. pathsep .. "AREA01V.SMK", 251572);
    check_corrupt("ANIMS" .. pathsep .. "WINGAME.SMK", 2066656);
    check_corrupt("ANIMS" .. pathsep .. "WINLEVEL.SMK", 335220);
    check_corrupt("INTRO" .. pathsep .. "INTRO.SM4", 33616520);
    check_corrupt("QDATA" .. pathsep .. "FONT00V.DAT", 1024);
    check_corrupt("ANIMS" .. pathsep .. "LOSE1.SMK", 1009728);
  }

  if( #corrupt != 0 ) {
    table.insert(corrupt, 1, "There appears to be corrupt files in your Theme Hospital folder, " ..
    "so don't be surprised if CorsixTH crashes. At least the following files are wrong:");
    table.insert(corrupt, message);
  }

  return true, #corrupt != 0 && corrupt || null;
}

//! Get the directory containing the bitmap files.
//!return Name of the directory containing the bitmap files, ending with a
//        directory path separator.
function App::getBitmapDir() {
  return (this.command_line["bitmap-dir"] || "Bitmap") .. pathsep;
}

// Load bitmap data into memory.
//!param filename Name of the file to load.
//!return The loaded data.
function App::readBitmapDataFile(filename) {
  filename = this->getBitmapDir() .. filename;
  var file = assert(io.open(filename, "rb"));
  var data = file->read("*a");
  file->close();
  if( data->sub(1, 3) == "RNC" ) {
    data = assert(rnc.decompress(data));
  }
  return data;
}

// Read a data file of the application into memory (possibly with decompression).
//!param dir (string) Directory to read from. "Bitmap" and "Levels" are
//       meta-directories, and get resolved to real directories in the function.
//!param filename (string or nil) If specified, the file to load. If 'nil', the
//       'dir' parameter is the filename in the "Data" directory.
function App::readDataFile(dir, filename) {
  if( dir == "Bitmap" ) {
    return this->readBitmapDataFile(filename);
  } else if( dir == "Levels" ) {
    return this->readMapDataFile(filename);
  }
  if( filename == null ) {
    dir, filename = "Data", dir;
  }
  var data = assert(this.fs->readContents(dir .. pathsep .. filename));
  if( data->sub(1, 3) == "RNC" ) {
    data = assert(rnc.decompress(data));
  }
  return data;
}

//! Get a level file.
//!param filename (string) Name of the level file.
//!return If the file could be found, the data of the file, else a
//        tuple 'null', and an error description
function App::readMapDataFile(filename) {
  // First look in the original install directory, if not found there
  // look in the CorsixTH directories "Levels" and "Campaigns".
  var data = this.fs->readContents("Levels" .. pathsep .. filename);
  if( ! data ) {
    var absolute_path = this->getAbsolutePathToLevelFile(filename);
    if( absolute_path ) {
      var file = io.open(absolute_path, "rb");
      if( file ) {
        data = file->read("*a");
        file->close();
      }
    }
  }
  if( data ) {
    if( data->sub(1, 3) == "RNC" ) {
      data = assert(rnc.decompress(data));
    }
  } else {
    // Could not find the file
    return null, _S.errors.map_file_missing->format(filename);
  }
  return data;
}

function App::loadLuaFolder(dir, no_results, append_to) {
  var ourpath = debug.getinfo(1, "S").source->sub(2, -8);
  dir = dir .. pathsep;
  var path = ourpath .. dir;
  var results = no_results && "" || (append_to || {});
  for( file in lfs.dir(path) ) {
    if( file->match("%.ljs$") ) {
      var status, result = pcall(corsixth.require, dir .. file->sub(1, -5));
      if( ! status ) {
        print("Error loading " .. dir ..  file .. ":\n" .. tostring(result));
      } else {
        if( result == null ) {
          if( ! no_results ) {
            print("Warning: " .. dir .. file .. " returned no value");
          }
        } else {
          if( no_results ) {
            print("Warning: " .. dir .. file .. " returned a value:", result);
          } else {
            if( type(result) == "table" && result.id ) {
              results[result.id] = result;
            } else if( type(result) == "function" ) {
              results[file->match("(.*)%.")] = result;
            }
            results[#results + 1] = result;
          }
        }
      }
    }
  }
  if( no_results ) {
    return;
  } else {
    return results;
  }
}

//! Returns the version number (name) of the local copy of the game based on
//! which save game version it is. This was added after the Beta 8
//! release, which is why the checks prior to that version aren't made.
//!param version An optional value if you want to find what game version
// a specific savegame verion is from.
function App::getVersion(version) {
  var ver = version || this.savegame_version;
  if( ver > 127 ) {
    return "Trunk";
  } else if( ver > 122 ) {
    return "v0.62";
  } else if( ver > 111 ) {
    return "v0.61";
  } else if( ver > 105 ) {
    return "v0.60";
  } else if( ver > 91 ) {
    return "0.50";
  } else if( ver > 78 ) {
    return "0.40";
  } else if( ver > 72 ) {
    return "0.30";
  } else if( ver > 66 ) {
    return "0.21";
  } else if( ver > 54 ) {
    return "0.20";
  } else if( ver > 53 ) {
    return "0.11";
  } else if( ver > 51 ) {
    return "0.10";
  } else if( ver > 45 ) {
    return "0.01";
  } else {
    return "Beta 8 or earlier";
  }
}

function App::save(filename) {
  return SaveGameFile(filename);
}

// Omit the usual file extension so this file cannot be seen from the normal load and save screen and cannot be overwritten
function App::quickSave() {
  var filename = "quicksave";
  return SaveGameFile(this.savegame_dir .. filename);
}

function App::load(filepath) {
  if( this.world ) {
    this->worldExited();
  }
  return LoadGameFile(filepath);
}

function App::quickLoad() {
  var filename = "quicksave";
  if( lfs.attributes(this.savegame_dir .. filename) ) {
    this->load(filename);
  } else {
    this->quickSave();
    this.ui->addWindow(UIInformation(this.ui, {_S.errors.load_quick_save}));
  }
}

//! Restarts the current level (offers confirmation window first)
function App::restart() {
  assert(this.map, "Trying to restart while no map is loaded.");
  this.ui->addWindow(UIConfirmDialog(this.ui, _S.confirmation.restart_level,
  /*persistable:app_confirm_restart*/ function() {
    this->worldExited();
    var level = this.map.level_number;
    var difficulty = this.map.difficulty;
    var name, file, intro;
    if( ! tonumber(level) ) {
      name = this.map.level_name;
      file = this.map.map_file;
      intro = this.map.level_intro;
    }
    if( level && name && ! file ) {
      this.ui->addWindow(UIInformation(this.ui, {_S.information.cannot_restart}));
      return;
    }
    var status, err = pcall(this.loadLevel, this, level, difficulty, name, file, intro);
    if( ! status ) {
      err = "Error while loading level: " .. err;
      print(err);
      this.ui->addWindow(UIInformation(this.ui, {err}));
    }
  }));
}

//! Begin the map editor
function App::mapEdit() {
  this->loadLevel("", null, null, null, null, true);
}

//! Exits the game completely (no confirmation window)
function App::exit() {
  // Save config before exiting
  this->saveConfig();
  this.running = false;
}

//! Exits the game completly without saving the config i.e. Alt+F4 for Quit Application
function App::abandon() {
  this.running = false;
}

//! This function is automatically called after loading a game and serves for compatibility.
function App::afterLoad() {
  this.ui->addOrRemoveDebugModeKeyHandlers();
  var old = this.world.savegame_version || 0;
  var new = this.savegame_version;

  if( old == 0 ) {
    // Game log was not present before introduction of savegame versions, so create it now.
    this.world.game_log = {};
    this.world->gameLog("Created Gamelog on load of old (pre-versioning) savegame.");
  }
  if( ! this.world.original_savegame_version ) {
    this.world.original_savegame_version = old;
  }
  var first = this.world.original_savegame_version;
  if( new == old ) {
    this.world->gameLog("Savegame version is " .. new .. " (" .. this->getVersion() ..
        "), originally it was " .. first .. " (" .. this->getVersion(first) .. ")");
    this.world->playLoadedEntitySounds();
    return;
  } else if( new > old ) {
    this.world->gameLog("Savegame version changed from " .. old .. " (" .. this->getVersion(old) ..
                       ") to " .. new .. " (" .. this->getVersion() ..
                       "). The save was created using " .. first ..
                       " (" .. this->getVersion(first) .. ")");
  } else {
    // TODO: This should maybe be forbidden completely.
    this.world->gameLog("Warning: loaded savegame version " .. old .. " (" .. this->getVersion(old) ..
                       ")" .. " in older version " .. new .. " (" .. this->getVersion() .. ").");
  }
  this.world.savegame_version = new;

  if( old < 87 ) {
    var new_object = corsixth.require("objects.gates_to_hell");
    Object.processTypeDefinition(new_object);
    this.objects[new_object.id] = new_object;
    this.world->newObjectType(new_object);
  }

  if( old < 114 ) {
    var rathole_type = corsixth.require("objects.rathole");
    Object.processTypeDefinition(rathole_type);
    this.objects[rathole_type.id] = rathole_type;
    this.world->newObjectType(rathole_type);
  }

  this.map->afterLoad(old, new);
  this.world->afterLoad(old, new);
  this.ui->afterLoad(old, new);
}

function App::checkForUpdates() {
  // Only check for updates once per application launch
  if( ! this.check_for_updates || ! this.config.check_for_updates ) { return; }
  this.check_for_updates = false;

  // Default language to use for the changelog if no localised version is available
  var default_language = "en";
  var update_url = 'http://www.corsixth.com/check-for-updates';
  var current_version = this->getVersion();

  // Only URLs that match this list of trusted domains will be accepted.
  var trusted_domains = { 'corsixth.com', 'code.google.com' };

  // Only check for updates against released versions
  if( current_version == "Trunk" ) {
    print("Will not check for updates since this is the Trunk version.");
    return;
  }

  var success, _ = pcall(require, "socket");

  if( ! success ) {
    // LuaSocket is not available, just return
    print("Cannot check for updates since LuaSocket is not available.");
    return;
  } else {
    this.lua_socket_available = true;
  }
  var http = require("socket.http");
  var url = require("socket.url");

  print("Checking for CorsixTH updates...");
  var update_body, status, _ = http.request(update_url);

  if( ! update_body || ! (status == 200) ) {
    print("Couldn't check for updates. Server returned code: " .. status);
    print("Check that you have an active internet connection and that CorsixTH is allowed in your firewall.");
    return;
  }

  var update_table = loadstring_envcall(update_body, "@updatechecker")({});
  var changelog = update_table["changelog_" .. default_language];
  var new_version = update_table["major"] .. '.' .. update_table["minor"] .. update_table["revision"];

  if( (new_version <= current_version) ) {
    print("You are running the latest version of CorsixTH.");
    return;
  }

  // Check to make sure download URL is trusted
  var download_url = url.parse(update_table["download_url"]);
  var valid_url = false;
  for( _,v in ipairs(trusted_domains) ) {
    if( download_url.host == v ) {
      valid_url = true;
      break;
    }
  }
  if( ! valid_url ) {
    print("Update download url is not on the trusted domains list (" .. update_table["download_url"] .. ")");
    return;
  }

  // Check to see if there's a changelog in the user's language
  var current_langs = this.strings->getLanguageNames(this.config.language);
  for( _, v in ipairs(current_langs) ) {
    if( (update_table["changelog_" .. v]) ) {
      changelog = update_table["changelog_" .. v];
      break;
    }
  }

  print("New version found: " .. new_version);
  // Display the update window
  this.ui->addWindow(UIUpdate(this.ui, current_version, new_version, changelog, update_table["download_url"]));
}

// Free up / stop any resources relying on the current video object
function App::prepareVideoUpdate() {
  this.video->endFrame();
  this.moviePlayer->deallocatePictureBuffer();
}

// Update / start any resources relying on a video object
function App::finishVideoUpdate() {
  this.gfx->updateTarget(this.video);
  this.moviePlayer->updateRenderer();
  this.moviePlayer->allocatePictureBuffer();
  this.video->startFrame();
}

// Do not remove, for savegame compatibility < r1891
var app_confirm_quit_stub = /*persistable:app_confirm_quit*/ function() {
};
