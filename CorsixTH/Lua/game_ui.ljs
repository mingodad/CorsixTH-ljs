/* Copyright (c) 2010 Manuel "Roujin" Wolf

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE. --*/

corsixth.require("ui");

//! Variant of UI for running games
class ("GameUI") (UI);

//-@type GameUI
var GameUI = _G["GameUI"];

var TH = require("TH");

// The maximum distance to shake the screen from the origin during an
// earthquake with full intensity.
var shake_screen_max_movement = 50; //pixels

// 0.002 is about 5 pixels on a 1920 pixel display
var multigesture_pinch_sensitivity_factor = 0.002;
// combined with the above, multiplying by 100 means minimum current_momentum.z for any detected pinch
// will result in a call to adjustZoom in the onTick method
var multigesture_pinch_amplification_factor = 100;

//! Game UI constructor.
//!param app (Application) Application object.
//!param local_hospital Hospital to display
//!param map_editor (bool) Whether the map is editable.
function GameUI::GameUI(app, local_hospital, map_editor) {
  this->UI(app);

  this.hospital = local_hospital;
  this.tutorial = { chapter = 0, phase = 0 };
  if( map_editor ) {
    this.map_editor = UIMapEditor(this);
    this->addWindow(this.map_editor);
  } else {
    this.adviser = UIAdviser(this);
    this.bottom_panel = UIBottomPanel(this);
    this.bottom_panel->addWindow(this.adviser);
    this->addWindow(this.bottom_panel);
  }

  // UI widgets
  this.menu_bar = UIMenuBar(this, this.map_editor);
  this->addWindow(this.menu_bar);

  var scr_w = app.config.width;
  var scr_h = app.config.height;
  this.visible_diamond = this->makeVisibleDiamond(scr_w, scr_h);
  if( this.visible_diamond.w <= 0 || this.visible_diamond.h <= 0 ) {
    // For a standard 128x128 map, screen size would have to be in the
    // region of 3276x2457 in order to be too large.
    if( ! this.map_editor ) {
      error("Screen size too large for the map");
    }
  }
  this.screen_offset_x, this.screen_offset_y = app.map->WorldToScreen(
    app.map.th->getCameraTile(local_hospital->getPlayerIndex()));
  this.zoom_factor = 1;
  this->scrollMap(-scr_w / 2, 16 - scr_h / 2);
  this.limit_to_visible_diamond = ! this.map_editor;
  this.transparent_walls = false;
  this.do_world_hit_test = true;

  this->setRandomAnnouncementTarget();
  this.ticks_since_last_announcement = 0;

  this.momentum = app.config.scrolling_momentum;
  this.current_momentum = {x = 0.0, y = 0.0, z = 0.0};
  this.multigesturemove = {x = 0.0, y = 0.0};

  this.speed_up_key_pressed = false;

  // The currently specified intensity value for earthquakes. To abstract
  // the effect from the implementation this value is a number between 0
  // and 1.
  this.shake_screen_intensity = 0;
}

function GameUI::setupGlobalKeyHandlers() {
  UI.setupGlobalKeyHandlers(this);

  this->addKeyHandler("escape", this, this.setEditRoom, false);
  this->addKeyHandler("escape", this, this.showMenuBar);
  this->addKeyHandler("z", this, this.keySpeedUp);
  this->addKeyHandler("x", this, this.keyTransparent);
  this->addKeyHandler({"shift", "a"}, this, this.toggleAdviser);
  this->addKeyHandler({"ctrl", "d"}, this.app.world, this.app.world.dumpGameLog);
  this->addKeyHandler({"ctrl", "t"}, this.app, this.app.dumpStrings);
  this->addKeyHandler({"alt", "a"}, this, this.togglePlayAnnouncements);
  this->addKeyHandler({"alt", "s"}, this, this.togglePlaySounds);
  this->addKeyHandler({"alt", "m"}, this, this.togglePlayMusic);

  if( this.app.config.debug ) {
    this->addKeyHandler("f11", this, this.showCheatsWindow);
  }
}

function GameUI::makeVisibleDiamond(scr_w, scr_h) {
  var map_w = this.app.map.width;
  var map_h = this.app.map.height;
  assert(map_w == map_h, "UI limiter requires square map");

  // The visible diamond is the region which the top-left corner of the screen
  // is limited to, and ensures that the map always covers all of the screen.
  // Its vertices are at (x + w, y), (x - w, y), (x, y + h), (x, y - h).
  return {
    x = - scr_w / 2,
    y = 16 * map_h - scr_h / 2,
    w = 32 * map_h - scr_h - scr_w / 2,
    h = 16 * map_h - scr_h / 2 - scr_w / 4,
  };
}

//! Calculate the minimum valid zoom value
//!
//! Zooming out too much would cause negative width/height to be returned from
//! makeVisibleDiamond. This function calculates the minimum zoom_factor that
//! would be allowed.
function GameUI::calculateMinimumZoom() {
  var scr_w = this.app.config.width;
  var scr_h = this.app.config.height;
  var map_h = this.app.map.height;

  // Minimum width:  0 = 32 * map_h - (scr_h/factor) - (scr_w/factor) / 2,
  // Minimum height: 0 = 16 * map_h - (scr_h/factor) / 2 - (scr_w/factor) / 4
  // Both rearrange to:
  var factor = (scr_w + 2 * scr_h) / (64 * map_h);

  // Due to precision issues a tolerance is needed otherwise setZoom might fail
  factor +=   0.001;

  return factor;
}

function GameUI::setZoom(factor) {
  if( factor <= 0 ) {
    return false;
  }
  if( ! factor || math.abs(factor - 1) < 0.001 ) {
    factor = 1;
  }

  var scr_w = this.app.config.width;
  var scr_h = this.app.config.height;
  var new_diamond = this->makeVisibleDiamond(scr_w / factor, scr_h / factor);
  if( new_diamond.w < 0 || new_diamond.h < 0 ) {
    return false;
  }

  this.visible_diamond = new_diamond;
  var refx, refy = this.cursor_x || scr_w / 2, this.cursor_y || scr_h / 2;
  var cx, cy = this->ScreenToWorld(refx, refy);
  this.zoom_factor = factor;

  cx, cy = this.app.map->WorldToScreen(cx, cy);
  cx = cx - this.screen_offset_x - refx / factor;
  cy = cy - this.screen_offset_y - refy / factor;
  this->scrollMap(cx, cy);
  return true;
}

function GameUI::draw(canvas) {
  var app = this.app;
  var config = app.config;
  if( this.map_editor || ! this.in_visible_diamond ) {
    canvas->fillBlack();
  }
  var zoom = this.zoom_factor;
  var dx = this.screen_offset_x +
      math.floor((0.5 - math.random()) * this.shake_screen_intensity * shake_screen_max_movement * 2);
  var dy = this.screen_offset_y +
      math.floor((0.5 - math.random()) * this.shake_screen_intensity * shake_screen_max_movement * 2);
  if( canvas->scale(zoom) ) {
    app.map->draw(canvas, dx, dy, math.floor(config.width / zoom), math.floor(config.height / zoom), 0, 0);
    canvas->scale(1);
  } else {
    this->setZoom(1);
    app.map->draw(canvas, dx, dy, config.width, config.height, 0, 0);
  }
  Window.draw(this, canvas, 0, 0); // NB: not calling UI.draw on purpose
  this->drawTooltip(canvas);
  if( this.simulated_cursor ) {
    this.simulated_cursor.draw(canvas, this.cursor_x, this.cursor_y);
  }
}

function GameUI::onChangeResolution() {
  // Calculate and enforce minimum zoom
  var minimum_zoom = this->calculateMinimumZoom();
  if( this.zoom_factor < minimum_zoom ) {
    this->setZoom(minimum_zoom);
  }
  // Recalculate scrolling bounds
  var scr_w = this.app.config.width;
  var scr_h = this.app.config.height;
  this.visible_diamond = this->makeVisibleDiamond(scr_w / this.zoom_factor, scr_h / this.zoom_factor);
  this->scrollMap(0, 0);

  UI.onChangeResolution(this);
}

//! Update UI state after the UI has been depersisted
//! When an UI object is depersisted, its state will reflect how the UI was at
// the moment of persistence, which may be different to the keyboard / mouse
// state at the moment of depersistence.
//!param ui (UI) The previously existing UI object, from which values should be
// taken.
function GameUI::resync(ui) {
  if( this.drag_mouse_move ) {
    // Check that a window is actually being dragged. If none is found, then
    // remove the drag handler.
    var something_being_dragged = false;
    for( _, window in ipairs(this.windows) ) {
      if( window.dragging ) {
        something_being_dragged = true;
        break;
      }
    }
    if( ! something_being_dragged ) {
      this.drag_mouse_move = null;
    }
  }
  this.tick_scroll_amount = ui.tick_scroll_amount;
  this.down_count = ui.down_count;
  if( ui.limit_to_visible_diamond != null ) {
    this.limit_to_visible_diamond = ui.limit_to_visible_diamond;
  }

  this.key_remaps = ui.key_remaps;
  this.key_to_button_remaps = ui.key_to_button_remaps;
}

var scroll_keys = {
  up    = {x =   0, y = -10},
  right = {x =  10, y =   0},
  down  = {x =   0, y =  10},
  left  = {x = -10, y =   0},
  ["keypad 8"] = {x =   0, y = -10},
  ["keypad 6"] = {x =  10, y =   0},
  ["keypad 2"] = {x =   0, y =  10},
  ["keypad 4"] = {x = -10, y =   0},
};

function GameUI::updateKeyScroll() {
  var dx, dy = 0, 0;
  for( key, scr in pairs(scroll_keys) ) {
    if( this.buttons_down[key] ) {
      dx = dx + scr.x;
      dy = dy + scr.y;
    }
  }
  if( dx != 0 || dy != 0 ) {
    this.tick_scroll_amount = {x = dx, y = dy};
    return true;
  } else {
    this.tick_scroll_amount = false;
    return false;
  }
}

function GameUI::keySpeedUp() {
  this.speed_up_key_pressed = true;
  this.app.world->speedUp();
}

function GameUI::keyTransparent() {
  this->setWallsTransparent(true);
}

function GameUI::onKeyDown(rawchar, modifiers, is_repeat) {
  if( UI.onKeyDown(this, rawchar, modifiers, is_repeat) ) {
    // Key has been handled already
    return true;
  }
  var key = rawchar->lower();
  if( scroll_keys[key] ) {
    this->updateKeyScroll();
    return;
  }
}

function GameUI::onKeyUp(rawchar) {
  if( UI.onKeyUp(this, rawchar) ) {
    return true;
  }

  var key = rawchar->lower();
  if( scroll_keys[key] ) {
    this->updateKeyScroll();
    return;
  }

  // Guess that the "Speed Up" key was released because the
  // code parameter can't provide UTF-8 key codes:
  this.speed_up_key_pressed = false;
  if( this.app.world->isCurrentSpeed("Speed Up") ) {
    this.app.world->previousSpeed();
  }

  this->setWallsTransparent(false);
}

function GameUI::makeDebugFax() {
  var message = {
    {text = "debug fax"}, // no translation needed imo
    choices = {{text = "close debug fax", choice = "close"}},
  };
  // Don't use "strike" type here, as these open a different window and must have an owner
  var types = {"emergency", "epidemy", "personality", "information", "disease", "report"};
  this.bottom_panel->queueMessage(types[math.random(1, #types)], message);
}

function GameUI::ScreenToWorld(x, y) {
  var zoom = this.zoom_factor;
  return this.app.map->ScreenToWorld(this.screen_offset_x + x / zoom, this.screen_offset_y + y / zoom);
}

function GameUI::WorldToScreen(x, y) {
  var zoom = this.zoom_factor;
  x, y = this.app.map->WorldToScreen(x, y);
  x = x - this.screen_offset_x;
  y = y - this.screen_offset_y;
  return x * zoom, y * zoom;
}

function GameUI::getScreenOffset() {
  return this.screen_offset_x, this.screen_offset_y;
}

//! Change if the World should be tested for entities under the cursor
//!param mode (boolean or room) true to enable hit test (normal), false
//! to disable, room to enable only for non-door objects in given room
function GameUI::setWorldHitTest(mode) {
  this.do_world_hit_test = mode;
}

function GameUI::onCursorWorldPositionChange() {
  var zoom = this.zoom_factor;
  var x = math.floor(this.screen_offset_x + this.cursor_x / zoom);
  var y = math.floor(this.screen_offset_y + this.cursor_y / zoom);
  var entity = null;
  if( this.do_world_hit_test && ! this->hitTest(this.cursor_x, this.cursor_y) ) {
    entity = this.app.map.th->hitTestObjects(x, y);
    if( this.do_world_hit_test != true ) {
      // limit to non-door objects in room
      var room = this.do_world_hit_test;
      entity = entity && class.is(entity, Object) &&
          entity->getRoom() == room && entity != room.door && entity;
    }
  }
  if( entity != this.cursor_entity ) {
    // Stop displaying hoverable moods for the old entity
    if( this.cursor_entity ) {
      this.cursor_entity->setMood(null);
    }

    // Make the entity easily accessible when debugging, and ignore "deselecting" an entity.
    if( entity ) {
      this.debug_cursor_entity = entity;
    }

    var epidemic = this.hospital.epidemic;
    var infected_cursor = TheApp.gfx->loadMainCursor("epidemic");
    var epidemic_cursor = TheApp.gfx->loadMainCursor("epidemic_hover");

    this.cursor_entity = entity;
    if( this.cursor != this.edit_room_cursor && this.cursor != this.waiting_cursor ) {
      var cursor = this.default_cursor;
      if( this.app.world.user_actions_allowed ) {
        //- If the patient is infected show the infected cursor
        if( epidemic && epidemic.coverup_in_progress &&
          entity && entity.infected && ! epidemic.timer.closed ) {
          cursor = infected_cursor;
          // In vaccination mode display epidemic hover cursor for all entities
        } else if( epidemic && epidemic.vaccination_mode_active ) {
          cursor = epidemic_cursor;
          // Otherwise just show the normal cursor and hover if appropriate
        } else {
          cursor = entity && entity.hover_cursor ||
          (this.down_count != 0 && this.down_cursor || this.default_cursor);
        }
      }
      this->setCursor(cursor);
    }
    if( this.bottom_panel ) {
      this.bottom_panel->setDynamicInfo(null);
    }
  }

  // Queueing icons over patients
  var wx, wy = this->ScreenToWorld(this.cursor_x, this.cursor_y);
  wx = math.floor(wx);
  wy = math.floor(wy);
  var room;
  if( wx > 0 && wy > 0 && wx < this.app.map.width && wy < this.app.map.height ) {
    room = this.app.world->getRoom(wx, wy);
  }
  if( room != this.cursor_room ) {
    // Unset queue mood for patients queueing the old room
    if( this.cursor_room ) {
      var queue = this.cursor_room.door.queue;
      if( queue ) {
        for( _, humanoid in ipairs(queue) ) {
          humanoid->setMood("queue", "deactivate");
        }
      }
    }
    // Set queue mood for patients queueing the new room
    if( room ) {
      var queue = room.door.queue;
      if( queue ) {
        for( _, humanoid in ipairs(queue) ) {
          humanoid->setMood("queue", "activate");
        }
      }
    }
    this.cursor_room = room;
  }

  // Any hoverable mood should be displayed on the new entity
  if( class.is(entity, Humanoid) ) {
    for( _, value in pairs(entity.active_moods) ) {
      if( value.on_hover ) {
        entity->setMoodInfo(value);
        break;
      }
    }
  }
  // Dynamic info
  if( entity && this.bottom_panel ) {
    this.bottom_panel->setDynamicInfo(entity->getDynamicInfo());
  }

  return Window.onCursorWorldPositionChange(this, this.cursor_x, this.cursor_y);
}

var UpdateCursorPosition = TH.cursor.setPosition;

var highlight_x, highlight_y;

//! Called when the mouse enters or leaves the game window.
function GameUI::onWindowActive(gain) {
  if( gain == 0 ) {
    this.tick_scroll_amount_mouse = false;
  }
}

// TODO: try to remove duplication with UI:onMouseMove
function GameUI::onMouseMove(x, y, dx, dy) {
  var repaint = UpdateCursorPosition(this.app.video, x, y);
  if( this.app.moviePlayer.playing ) {
    return false;
  }

  this.cursor_x = x;
  this.cursor_y = y;
  if( this->onCursorWorldPositionChange() || this.simulated_cursor ) {
    repaint = true;
  }
  if( this.buttons_down.mouse_middle ) {
    var zoom = this.zoom_factor;
    this.current_momentum.x = -dx/zoom;
    this.current_momentum.y = -dy/zoom;
    // Stop zooming when the middle mouse button is pressed
    this.current_momentum.z = 0;
    this->scrollMap(this.current_momentum.x, this.current_momentum.y);
    repaint = true;
  }

  if( this.drag_mouse_move ) {
    this.drag_mouse_move(x, y);
    return true;
  }

  var scroll_region_size;
  if( this.app.config.fullscreen ) {
    // As the mouse is locked within the window, a 1px region feels a lot
    // larger than it actually is.
    scroll_region_size = 1;
  } else {
    // In windowed mode, a reasonable size is needed, though not too large.
    scroll_region_size = 8;
  }
  if( ! this.app.config.prevent_edge_scrolling &&
      (x < scroll_region_size || y < scroll_region_size ||
       x >= this.app.config.width - scroll_region_size ||
       y >= this.app.config.height - scroll_region_size) ) {
    var scroll_dx = 0;
    var scroll_dy = 0;
    var scroll_power = 7;
    if( x < scroll_region_size ) {
      scroll_dx = -scroll_power;
    } else if( x >= this.app.config.width - scroll_region_size ) {
      scroll_dx = scroll_power;
    }
    if( y < scroll_region_size ) {
      scroll_dy = -scroll_power;
    } else if( y >= this.app.config.height - scroll_region_size ) {
      scroll_dy = scroll_power;
    }

    if( ! this.tick_scroll_amount_mouse ) {
      this.tick_scroll_amount_mouse = {x = scroll_dx, y = scroll_dy};
    } else {
      this.tick_scroll_amount_mouse.x = scroll_dx;
      this.tick_scroll_amount_mouse.y = scroll_dy;
    }
  } else {
    this.tick_scroll_amount_mouse = false;
  }

  if( Window.onMouseMove(this, x, y, dx, dy) ) {
    repaint = true;
  }

  this->updateTooltip();

  var map = this.app.map;
  var wx, wy = this->ScreenToWorld(x, y);
  wx = math.floor(wx);
  wy = math.floor(wy);
  if( highlight_x ) {
    //map.th:setCell(highlight_x, highlight_y, 4, 0)
    highlight_x = null;
  }
  if( 1 <= wx && wx <= 128 && 1 <= wy && wy <= 128 ) {
    if( map.th->getCellFlags(wx, wy).passable ) {
      //map.th:setCell(wx, wy, 4, 24 + 8 * 256)
      highlight_x = wx;
      highlight_y = wy;
    }
  }

  return repaint;
}

function GameUI::onMouseUp(code, x, y) {
  if( this.app.moviePlayer.playing ) {
    return UI.onMouseUp(this, code, x, y);
  }

  var button = this.button_codes[code];
  if( button == "right" && ! this.map_editor && highlight_x ) {
    var window = this->getWindow(UIPatient);
    var patient = (window && window.patient.is_debug && window.patient) || this.hospital->getDebugPatient();
    if( patient ) {
      patient->walkTo(highlight_x, highlight_y);
      patient->queueAction(IdleAction());
    }
  }

  if( this.edit_room ) {
    if( class.is(this.edit_room, Room) ) {
      if( button == "right" && this.cursor == this.waiting_cursor ) {
        // Still waiting for people to leave the room, abort editing it.
        this->setEditRoom(false);
      }
    } else { // No room chosen yet, but about to edit one.
      if( button == "left" ) { // Take the clicked one.
        var room = this.app.world->getRoom(this->ScreenToWorld(x, y));
        if( room && ! room.crashed ) {
          this->setCursor(this.waiting_cursor);
          this.edit_room = room;
          room->tryToEdit();
        }
      } else { // right click, we don't want to edit a room after all.
        this->setEditRoom(false);
      }
    }
  }

  // During vaccination mode you can only interact with infected patients
  var epidemic = this.hospital.epidemic;
  if( epidemic && epidemic.vaccination_mode_active ) {
    if( button == "left" ) {
      if( this.cursor_entity ) {
        // Allow click behaviour for infected patients
        if( this.cursor_entity.infected ) {
          this.cursor_entity->onClick(this,button);
        }
      }
    } else if( button == "right" ) {
      //Right click turns vaccination mode off
      var watch = TheApp.ui->getWindow(UIWatch);
      watch->toggleVaccinationMode();
    }
  }

  return UI.onMouseUp(this, code, x, y);
}

//! Process SDL_MULTIGESTURE events for zoom and map move functionality
//!param numfingers (integer) number of touch points, received from the SDL event
//!  This is still more info about param x.
//!param dTheta (float) rotation in radians of the gesture from the SDL event
//!param dDist (float) magnitude of pinch from the SDL event
//!param x (float) normalised x value of the gesture
//!param y (float) normalised y value of the gesture
//!return (boolean) event processed indicator
function GameUI::onMultiGesture(numfingers, dTheta, dDist, x, y) {
  // only deal with 2 finger events for now
  if( numfingers == 2 ) {
    // calculate magnitude of pinch
    var mag = math.abs(dDist);
    if( mag > multigesture_pinch_sensitivity_factor ) {
      // pinch action - constant needs to be tweaked
      this.current_momentum.z = this.current_momentum.z + dDist * multigesture_pinch_amplification_factor;
      return true;
    } else {
      // scroll map
      var normx = this.app.config.width * x;
      var normy = this.app.config.height * y;

      if( this.multigesturemove.x == 0.0 ) {
        this.multigesturemove.x = normx;
        this.multigesturemove.y = normy;
      } else {
        var dx = normx - this.multigesturemove.x;
        var dy = normy - this.multigesturemove.y;
        this.current_momentum.x = this.current_momentum.x - dx;
        this.current_momentum.y = this.current_momentum.y - dy;
        this.multigesturemove.x = normx;
        this.multigesturemove.y = normy;
      }
      return true;
    }
  }
  return false;
}

function GameUI::onMouseWheel(x, y) {
  var inside_window = false;
  if( this.windows ) {
    for( _, window in ipairs(this.windows) ) {
      if( window->hitTest(this.cursor_x - window.x, this.cursor_y - window.y) ) {
        inside_window = true;
        break;
      }
    }
  }
  if( ! inside_window ) {
    // Apply momentum to the zoom
    if( math.abs(this.current_momentum.z) < 12 ) {
      this.current_momentum.z = this.current_momentum.z + y;
    }
  }
  return UI.onMouseWheel(this, x, y);
}

function GameUI::setRandomAnnouncementTarget() {
  // NB: Every tick is 30ms, so 2000 ticks is 1 minute
  this.random_announcement_ticks_target = math.random(8000, 12000);
}

function GameUI::playAnnouncement(name, played_callback, played_callback_delay) {
  this.ticks_since_last_announcement = 0;
  if( this.app.world->getLocalPlayerHospital()->hasStaffedDesk() ) {
    UI.playAnnouncement(this, name, played_callback, played_callback_delay);
  }
}

function GameUI::onTick() {
  var repaint = UI.onTick(this);
  if( ! this.buttons_down.mouse_middle ) {
    if( math.abs(this.current_momentum.x) < 0.2 && math.abs(this.current_momentum.y) < 0.2 ) {
      // Stop scrolling
      this.current_momentum.x = 0.0;
      this.current_momentum.y = 0.0;
    } else {
      this.current_momentum.x = this.current_momentum.x * this.momentum;
      this.current_momentum.y = this.current_momentum.y * this.momentum;
      this->scrollMap(this.current_momentum.x, this.current_momentum.y);
    }
    if( math.abs(this.current_momentum.z) < 0.2 ) {
      this.current_momentum.z = 0.0;
    } else {
      this.current_momentum.z = this.current_momentum.z * this.momentum;
      this.app.world->adjustZoom(this.current_momentum.z);
    }
    this.multigesturemove.x = 0.0;
    this.multigesturemove.y = 0.0;
  }
  if( ! this.app.world->isCurrentSpeed("Pause") ) {
    var ticks_since_last_announcement = this.ticks_since_last_announcement;
    if( ticks_since_last_announcement >= this.random_announcement_ticks_target ) {
      this->playAnnouncement("rand*.wav");
      this->setRandomAnnouncementTarget();
    } else {
      this.ticks_since_last_announcement = ticks_since_last_announcement + 1;
    }
  }
  if( this.tick_scroll_amount || this.tick_scroll_amount_mouse ) {
    // The scroll amount per tick gradually increases as the duration of the
    // scroll increases due to this multiplier.
    var mult = this.tick_scroll_mult;
    mult +=   0.02;
    if( mult > 2 ) {
      mult = 2;
    }
    this.tick_scroll_mult = mult;

    // Combine the mouse scroll and keyboard scroll
    var dx, dy = 0, 0;
    if( this.tick_scroll_amount_mouse ) {
      dx, dy = this.tick_scroll_amount_mouse.x, this.tick_scroll_amount_mouse.y;
      // If the middle mouse button is down, then the world is being dragged,
      // and so the scroll direction due to the cursor being at the map edge
      // should be opposite to normal to make it feel more natural.
      if( this.buttons_down.mouse_middle ) {
        dx, dy = -dx, -dy;
      }
    }
    if( this.tick_scroll_amount ) {
      dx = dx + this.tick_scroll_amount.x;
      dy = dy + this.tick_scroll_amount.y;
    }

    // Adjust scroll speed based on config value:
    // there is a separate config value for whether or not shift is held.
    // the speed is multiplied by 0.5 for consistency between the old and
    // new configuration. In the past scroll_speed applied only to shift
    // and defaulted to 2, where 1 was regular scroll speed. By
    // By multiplying by 0.5, we allow for setting slower than normal
    // scroll speeds, and ensure there is no behaviour change for players
    // who do not modify their config file.
    if( this.app.key_modifiers.shift ) {
      mult = mult * this.app.config.shift_scroll_speed * 0.5;
    } else {
      mult = mult * this.app.config.scroll_speed * 0.5;
    }

    this->scrollMap(dx * mult, dy * mult);
    repaint = true;
  } else {
    this.tick_scroll_mult = 1;
  }
  if( this->onCursorWorldPositionChange() ) {
    repaint = true;
  }
  return repaint;
}

var abs, sqrt_5, floor = math.abs, math.sqrt(1 / 5), math.floor;

function GameUI::scrollMapTo(x, y) {
  var zoom = 2 * this.zoom_factor;
  var config = this.app.config;
  return this->scrollMap(x - this.screen_offset_x - config.width / zoom,
                        y - this.screen_offset_y - config.height / zoom);
}

function GameUI.limitPointToDiamond(dx, dy, visible_diamond, do_limit) {
  // If point outside visible diamond, then move point to the nearest position
  // on the edge of the diamond (NB: relies on diamond.w == 2 * diamond.h).
  var rx = dx - visible_diamond.x;
  var ry = dy - visible_diamond.y;
  if( abs(rx) + abs(ry) * 2 > visible_diamond.w ) {
    if( do_limit ) {
      // Determine the quadrant which the point lies in and accordingly set:
      //  (vx, vy) : a unit vector perpendicular to the diamond edge in the quadrant
      //  (p1x, p1y), (p2x, p2y) : the two diamond verticies in the quadrant
      //  d : distance from the point to the line defined by the diamond edge (not the line segment itself)
      var vx, vy, d;
      var p1x, p1y, p2x, p2y = 0, 0, 0, 0;
      if( rx >= 0 && ry >= 0 ) {
        p1x, p2y =  visible_diamond.w,  visible_diamond.h;
        vx, vy = sqrt_5, 2 * sqrt_5;
        d = (rx * vx + ry * vy) - (p1x * vx);
      } else if( rx >= 0 && ry < 0 ) {
        p2x, p1y =  visible_diamond.w, -visible_diamond.h;
        vx, vy = sqrt_5, -2 * sqrt_5;
        d = (rx * vx + ry * vy) - (p2x * vx);
      } else if( rx < 0 && ry >= 0 ) {
        p2x, p1y = -visible_diamond.w,  visible_diamond.h;
        vx, vy = -sqrt_5, 2 * sqrt_5;
        d = (rx * vx + ry * vy) - (p2x * vx);
      } else {//if rx < 0 and ry < 0 then
        p1x, p2y = -visible_diamond.w, -visible_diamond.h;
        vx, vy = -sqrt_5, -2 * sqrt_5;
        d = (rx * vx + ry * vy) - (p1x * vx);
      }
      // In the unit vector parallel to the diamond edge, resolve the two vertices and
      // the point, and either move the point to the edge or to one of the two vertices.
      // NB: vx, vy, p1x, p1y, p2x, p2y are set such that p1 < p2.
      var p1 = vx * p1y - vy * p1x;
      var p2 = vx * p2y - vy * p2x;
      var pd = vx * ry - vy * rx;
      if( pd < p1 ) {
        dx, dy = p1x + visible_diamond.x, p1y + visible_diamond.y;
      } else if( pd > p2 ) {
        dx, dy = p2x + visible_diamond.x, p2y + visible_diamond.y;
      } else {//if p1 <= pd and pd <= p2 then
        dx, dy = dx - d * vx, dy - d * vy;
      }
      return math.floor(dx), math.floor(dy), true;
    } else {
      return dx, dy, false;
    }
  }
  return dx, dy, true;
}

function GameUI::scrollMap(dx, dy) {
  dx = dx + this.screen_offset_x;
  dy = dy + this.screen_offset_y;

  dx, dy, this.in_visible_diamond = this.limitPointToDiamond(dx, dy,
    this.visible_diamond, this.limit_to_visible_diamond);

  this.screen_offset_x = floor(dx + 0.5);
  this.screen_offset_y = floor(dy + 0.5);
}

//! Start shaking the screen, e.g. an earthquake effect
//!param intensity (number) The magnitude of the effect, between 0 for no
// movement to 1 for significant shaking.
function GameUI::beginShakeScreen(intensity) {
  this.shake_screen_intensity = intensity;
}

//! Stop the screen from shaking after beginShakeScreen is called.
function GameUI::endShakeScreen() {
  this.shake_screen_intensity = 0;
}

function GameUI::limitCamera(mode) {
  this.limit_to_visible_diamond = mode;
  this->scrollMap(0, 0);
}

//! Applies the current setting for wall transparency to the map
function GameUI::applyTransparency() {
  this.app.map.th->setWallDrawFlags(this.transparent_walls && 4 || 0);
}

//! Sets wall transparency to the specified parameter
//!param mode (boolean) whether to enable or disable wall transparency
function GameUI::setWallsTransparent(mode) {
  if( mode != this.transparent_walls ) {
    this.transparent_walls = mode;
    this->applyTransparency();
  }
}

function UI::toggleAdviser() {
  this.app.config.adviser_disabled = ! this.app.config.adviser_disabled;
  this.app->saveConfig();
}

function UI::togglePlaySounds() {
  this.app.config.play_sounds = ! this.app.config.play_sounds;
  this.app.audio->playSoundEffects(this.app.config.play_sounds);
  this.app->saveConfig();
}

function UI::togglePlayAnnouncements() {
  this.app.config.play_announcements = ! this.app.config.play_announcements;
  this.app->saveConfig();
}

function UI::togglePlayMusic(item) {
  if( ! this.app.audio.background_music ) {
    this.app.config.play_music = true;
    this.app.audio->playRandomBackgroundTrack(); // play
  } else {
    this.app.config.play_music = false;
    this.app.audio->stopBackgroundTrack(); // stop
  }
 // self.app.config.play_music = not self.app.config.play_music
  this.app->saveConfig();
}

var tutorial_phases;
var function make_tutorial_phases() {
tutorial_phases = {
  {
    // 1) build reception
    { text = _A.tutorial.build_reception,              // 1
      begin_callback = function() { TheApp.ui->getWindow(UIBottomPanel)->startButtonBlinking(3); },
      end_callback = function() { TheApp.ui->getWindow(UIBottomPanel)->stopButtonBlinking(); }, },
    { text = _A.tutorial.order_one_reception,          // 2
      begin_callback = function() { TheApp.ui->getWindow(UIFurnishCorridor)->startButtonBlinking(3); },
      end_callback = function() { TheApp.ui->getWindow(UIFurnishCorridor)->stopButtonBlinking(3); }, },
    { text = _A.tutorial.accept_purchase,              // 3
      begin_callback = function() { TheApp.ui->getWindow(UIFurnishCorridor)->startButtonBlinking(2); },
      end_callback = function() { TheApp.ui->getWindow(UIFurnishCorridor)->stopButtonBlinking(2); }, },
    _A.tutorial.rotate_and_place_reception,            // 4
    _A.tutorial.reception_invalid_position,            // 5
                                                       // 6: object other than reception selected. currently no text for this phase.
  },

  {
    // 2) hire receptionist
    { text = _A.tutorial.hire_receptionist,            // 1
      begin_callback = function() { TheApp.ui->getWindow(UIBottomPanel)->startButtonBlinking(5); },
      end_callback = function() { TheApp.ui->getWindow(UIBottomPanel)->stopButtonBlinking(); }, },
    { text = _A.tutorial.select_receptionists,         // 2
      begin_callback = function() { TheApp.ui->getWindow(UIHireStaff)->startButtonBlinking(4); },
      end_callback = function() { TheApp.ui->getWindow(UIHireStaff)->stopButtonBlinking(); }, },
    { text = _A.tutorial.next_receptionist,            // 3
      begin_callback = function() { TheApp.ui->getWindow(UIHireStaff)->startButtonBlinking(8); },
      end_callback = function() { TheApp.ui->getWindow(UIHireStaff)->stopButtonBlinking(); }, },
    { text = _A.tutorial.prev_receptionist,            // 4
      begin_callback = function() { TheApp.ui->getWindow(UIHireStaff)->startButtonBlinking(5); },
      end_callback = function() { TheApp.ui->getWindow(UIHireStaff)->stopButtonBlinking(); }, },
    { text = _A.tutorial.choose_receptionist,          // 5
      begin_callback = function() { TheApp.ui->getWindow(UIHireStaff)->startButtonBlinking(6); },
      end_callback = function() { TheApp.ui->getWindow(UIHireStaff)->stopButtonBlinking(); }, },
    _A.tutorial.place_receptionist,                    // 6
    _A.tutorial.receptionist_invalid_position,         // 7
  },

  {
    // 3) build GP's office
    // 3.1) room window
    { text = _A.tutorial.build_gps_office,             // 1
      begin_callback = function() { TheApp.ui->getWindow(UIBottomPanel)->startButtonBlinking(2); },
      end_callback = function() { TheApp.ui->getWindow(UIBottomPanel)->stopButtonBlinking(); }, },
    { text = _A.tutorial.select_diagnosis_rooms,       // 2
      begin_callback = function() { TheApp.ui->getWindow(UIBuildRoom)->startButtonBlinking(1); },
      end_callback = function() { TheApp.ui->getWindow(UIBuildRoom)->stopButtonBlinking(); }, },
    { text = _A.tutorial.click_gps_office,             // 3
      begin_callback = function() { TheApp.ui->getWindow(UIBuildRoom)->startButtonBlinking(5); },
      end_callback = function() { TheApp.ui->getWindow(UIBuildRoom)->stopButtonBlinking(); }, },

    // 3.2) blueprint
    // [11][58] was maybe planned to be used in this place, but is not needed.
    _A.tutorial.click_and_drag_to_build,               // 4
    _A.tutorial.room_in_invalid_position,              // 5
    _A.tutorial.room_too_small,                        // 6
    _A.tutorial.room_too_small_and_invalid,            // 7
    { text = _A.tutorial.room_big_enough,              // 8
      begin_callback = function() { TheApp.ui->getWindow(UIEditRoom)->startButtonBlinking(4); },
      end_callback = function() { TheApp.ui->getWindow(UIEditRoom)->stopButtonBlinking(); }, },

    // 3.3) door and windows
    _A.tutorial.place_door,                            // 9
    _A.tutorial.door_in_invalid_position,              // 10
    { text = _A.tutorial.place_windows,                // 11
      begin_callback = function() { TheApp.ui->getWindow(UIEditRoom)->startButtonBlinking(4); },
      end_callback = function() { TheApp.ui->getWindow(UIEditRoom)->stopButtonBlinking(); }, },
    { text = _A.tutorial.window_in_invalid_position,   // 12
      begin_callback = function() { TheApp.ui->getWindow(UIEditRoom)->startButtonBlinking(4); },
      end_callback = function() { TheApp.ui->getWindow(UIEditRoom)->stopButtonBlinking(); }, },

    // 3.4) objects
    _A.tutorial.place_objects,                         // 13
    _A.tutorial.object_in_invalid_position,            // 14
    { text = _A.tutorial.confirm_room,                 // 15
      begin_callback = function() { TheApp.ui->getWindow(UIEditRoom)->startButtonBlinking(4); },
      end_callback = function() { TheApp.ui->getWindow(UIEditRoom)->stopButtonBlinking(); }, },
    { text = _A.tutorial.information_window,           // 16
      begin_callback = function() { TheApp.ui->getWindow(UIInformation)->startButtonBlinking(1); },
      end_callback = function() { TheApp.ui->getWindow(UIInformation)->stopButtonBlinking(); }, },
  },

  {
    // 4) hire doctor
    { text = _A.tutorial.hire_doctor,                  // 1
      begin_callback = function() { TheApp.ui->getWindow(UIBottomPanel)->startButtonBlinking(5); },
      end_callback = function() { TheApp.ui->getWindow(UIBottomPanel)->stopButtonBlinking(); }, },
    { text = _A.tutorial.select_doctors,               // 2
      begin_callback = function() { TheApp.ui->getWindow(UIHireStaff)->startButtonBlinking(1); },
      end_callback = function() { TheApp.ui->getWindow(UIHireStaff)->stopButtonBlinking(); }, },
    { text = _A.tutorial.choose_doctor,                // 3
      begin_callback = function() { TheApp.ui->getWindow(UIHireStaff)->startButtonBlinking(6); },
      end_callback = function() { TheApp.ui->getWindow(UIHireStaff)->stopButtonBlinking(); }, },
    _A.tutorial.place_doctor,                          // 4
    _A.tutorial.doctor_in_invalid_position,            // 5
  },
  {
    // 5) end of tutorial
    { begin_callback = function() {
        // The demo uses a single string for the post-tutorial info while
        // the real game uses three.
        var texts = TheApp.using_demo_files && {
          {_S.introduction_texts["level15"]},
          {_S.introduction_texts["demo"]},
        } || {
          {_S.introduction_texts["level15"]},
          {_S.introduction_texts["level16"]},
          {_S.introduction_texts["level17"]},
          {_S.introduction_texts["level1"]},
        };
        TheApp.ui->addWindow(UIInformation(TheApp.ui, texts));
        TheApp.ui->addWindow(UIWatch(TheApp.ui, "initial_opening"));
      },
    },
  },
};
}
tutorial_phases = setmetatable({}, {__index = function(t, k) {
  make_tutorial_phases();
  return tutorial_phases[k];
}});

// Called to trigger step to another part of the tutorial.
// chapter:    Individual parts of the tutorial. Step will only happen if it's the current chapter.
// phase_from: Phase we need to be in for this step to happen. Multiple phases can be given here in an array.
// phase_to:   Phase we want to step to or "next" to go to next chapter or "end" to end tutorial.
// returns true if we changed phase, false if we didn't
function GameUI::tutorialStep(chapter, phase_from, phase_to, ...) {
  if( this.tutorial.chapter != chapter ) {
    return false;
  }
  if( type(phase_from) == "table" ) {
    var contains_current = false;
    for( _, phase in ipairs(phase_from) ) {
      if( phase == this.tutorial.phase ) {
        contains_current = true;
        break;
      }
    }
    if( ! contains_current ) { return false; }
  } else {
    if( this.tutorial.phase != phase_from ) { return false; }
  }

  var old_phase = tutorial_phases[this.tutorial.chapter][this.tutorial.phase];
  if( old_phase && old_phase.end_callback && type(old_phase.end_callback) == "function" ) {
    old_phase.end_callback(...);
  }

  if( phase_to == "end" ) {
    this.tutorial.chapter = 0;
    this.tutorial.phase = 0;
    return true;
  } else if( phase_to == "next" ) {
    this.tutorial.chapter = this.tutorial.chapter + 1;
    this.tutorial.phase = 1;
  } else {
    this.tutorial.phase = phase_to;
  }

  if( TheApp.config.debug ) { print("Tutorial: Now in " .. this.tutorial.chapter .. ", " .. this.tutorial.phase); }
  var new_phase = tutorial_phases[this.tutorial.chapter][this.tutorial.phase];
  var str, callback;
  if( (type(new_phase) == "table" && type(new_phase.text) == "table") || ! new_phase.text ) {
    str = new_phase.text;
    callback = new_phase.begin_callback;
  } else {
    str = new_phase;
  }
  if( str && str.text ) {
    this.adviser->say(str, true, true);
  } else {
    this.adviser.stay_up = null;
  }
  if( callback ) {
    callback(...);
  }
  return true;
}

function GameUI::startTutorial(chapter) {
  chapter = chapter || 1;
  this.tutorial.chapter = chapter;
  this.tutorial.phase = 0;

  this->tutorialStep(chapter, 0, 1);
}

function GameUI::setEditRoom(enabled) {
  // TODO: Make the room the cursor is over flash
  if( enabled ) {
    this->setCursor(this.edit_room_cursor);
    this.edit_room = true;
  } else {
    // If the actual editing hasn't started yet but is on its way,
    // activate the room again.
    if( class.is(this.edit_room, Room) && this.cursor == this.waiting_cursor ) {
      this.edit_room.is_active = true;
    } else {
      // If we are currently editing a room it may happen that we need to abort it.
      // Also remove any dialog where the user is buying items.
      var item_window = this.app.ui->getWindow(UIFurnishCorridor);
      if( item_window && item_window.edit_dialog ) {
        item_window->close();
      }
      var edit_window = this.app.ui->getWindow(UIEditRoom);
      if( edit_window ) {
        edit_window->verifyOrAbortRoom();
      }
    }
    this->setCursor(this.default_cursor);
    this.edit_room = false;
  }
}

function GameUI::afterLoad(old, new) {
  if( old < 16 ) {
    this.zoom_factor = 1;
  }
  if( old < 23 ) {
    this.do_world_hit_test = ! this->getWindow(UIPlaceObjects);
  }
  if( old < 28 ) {
    this->setRandomAnnouncementTarget();
    this.ticks_since_last_announcement = 0;
  }
  if( old < 34 ) {
    this.adviser.queued_messages = {};
    this.adviser.phase = 0;
    this.adviser.timer = null;
    this.adviser.frame = 1;
    this.adviser.number_frames = 4;
  }
  if( old < 70 ) {
    this->addKeyHandler({"shift", "a"}, this, this.toggleAdviser);
  }
  if( old < 75 ) {
    this.current_momentum = { x = 0, y = 0 };
    this.momentum = this.app.config.scrolling_momentum;
  }
  if( old < 78 ) {
    this.current_momentum = { x = 0, y = 0, z = 0};
  }
  if( old < 81 ) {
    this->removeKeyHandler("x", this, this.toggleWallsTransparent);
    this->addKeyHandler("z", this, this.keySpeedUp);
    this->addKeyHandler("x", this, this.keyTransparent);
  }
  if( old < 115 ) {
    this.shake_screen_intensity = 0;
  }
  if( old < 122 ) {
    this.multigesturemove = {x = 0.0, y = 0.0};
  }
  return UI.afterLoad(this, old, new);
}

function GameUI::showBriefing() {
  var level = this.app.world.map.level_number;
  var text = {_S.information.custom_game};
  if( type(level) == "number" ) {
    text = {_S.introduction_texts[TheApp.using_demo_files && "demo" || "level" .. level]};
  } else if( this.app.world.map.level_intro ) {
    text = {this.app.world.map.level_intro};
  }
  this->addWindow(UIInformation(this, text));
}

//! Offers a confirmation window to quit the game and return to main menu
// NB: overrides UI.quit, do NOT call it from here
function GameUI::quit() {
  this->addWindow(UIConfirmDialog(this, _S.confirmation.quit, /*persistable:gameui_confirm_quit*/ function() {
    this.app->loadMainMenu();
  }));
}

function GameUI::showCheatsWindow() {
  this->addWindow(UICheats(this));
}

function GameUI::showMenuBar() {
  this.menu_bar->appear();
}
